{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar NodeUtil_js_1 = __importDefault(require(\"./NodeUtil.js\"));\nvar FilterUtil;\n(function (FilterUtil) {\n  FilterUtil.cleanStretchy = function (arg) {\n    var e_1, _a;\n    var options = arg.data;\n    try {\n      for (var _b = __values(options.getList('fixStretchy')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mo = _c.value;\n        if (NodeUtil_js_1.default.getProperty(mo, 'fixStretchy')) {\n          var symbol = NodeUtil_js_1.default.getForm(mo);\n          if (symbol && symbol[3] && symbol[3]['stretchy']) {\n            NodeUtil_js_1.default.setAttribute(mo, 'stretchy', false);\n          }\n          var parent_1 = mo.parent;\n          if (!NodeUtil_js_1.default.getTexClass(mo) && (!symbol || !symbol[2])) {\n            var texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n            parent_1.replaceChild(texAtom, mo);\n            texAtom.inheritAttributesFrom(mo);\n          }\n          NodeUtil_js_1.default.removeProperties(mo, 'fixStretchy');\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  FilterUtil.cleanAttributes = function (arg) {\n    var node = arg.data.root;\n    node.walkTree(function (mml, _d) {\n      var e_2, _a;\n      var attribs = mml.attributes;\n      if (!attribs) {\n        return;\n      }\n      var keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));\n      delete attribs.getAllAttributes()['mjx-keep-attrs'];\n      try {\n        for (var _b = __values(attribs.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n          if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {\n            delete attribs.attributes[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }, {});\n  };\n  FilterUtil.combineRelations = function (arg) {\n    var e_3, _a, e_4, _b;\n    var remove = [];\n    try {\n      for (var _c = __values(arg.data.getList('mo')), _e = _c.next(); !_e.done; _e = _c.next()) {\n        var mo = _e.value;\n        if (mo.getProperty('relationsCombined') || !mo.parent || mo.parent && !NodeUtil_js_1.default.isType(mo.parent, 'mrow') || NodeUtil_js_1.default.getTexClass(mo) !== MmlNode_js_1.TEXCLASS.REL) {\n          continue;\n        }\n        var mml = mo.parent;\n        var m2 = void 0;\n        var children = mml.childNodes;\n        var next = children.indexOf(mo) + 1;\n        var variantForm = NodeUtil_js_1.default.getProperty(mo, 'variantForm');\n        while (next < children.length && (m2 = children[next]) && NodeUtil_js_1.default.isType(m2, 'mo') && NodeUtil_js_1.default.getTexClass(m2) === MmlNode_js_1.TEXCLASS.REL) {\n          if (variantForm === NodeUtil_js_1.default.getProperty(m2, 'variantForm') && _compareExplicit(mo, m2)) {\n            NodeUtil_js_1.default.appendChildren(mo, NodeUtil_js_1.default.getChildren(m2));\n            _copyExplicit(['stretchy', 'rspace'], mo, m2);\n            try {\n              for (var _f = (e_4 = void 0, __values(m2.getPropertyNames())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var name_1 = _g.value;\n                mo.setProperty(name_1, m2.getProperty(name_1));\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n            children.splice(next, 1);\n            remove.push(m2);\n            m2.parent = null;\n            m2.setProperty('relationsCombined', true);\n          } else {\n            if (mo.attributes.getExplicit('rspace') == null) {\n              NodeUtil_js_1.default.setAttribute(mo, 'rspace', '0pt');\n            }\n            if (m2.attributes.getExplicit('lspace') == null) {\n              NodeUtil_js_1.default.setAttribute(m2, 'lspace', '0pt');\n            }\n            break;\n          }\n        }\n        mo.attributes.setInherited('form', mo.getForms()[0]);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n  var _copyExplicit = function (attrs, node1, node2) {\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    attrs.forEach(function (x) {\n      var attr = attr2.getExplicit(x);\n      if (attr != null) {\n        attr1.set(x, attr);\n      }\n    });\n  };\n  var _compareExplicit = function (node1, node2) {\n    var e_5, _a;\n    var filter = function (attr, space) {\n      var exp = attr.getExplicitNames();\n      return exp.filter(function (x) {\n        return x !== space && (x !== 'stretchy' || attr.getExplicit('stretchy'));\n      });\n    };\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    var exp1 = filter(attr1, 'lspace');\n    var exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    try {\n      for (var exp1_1 = __values(exp1), exp1_1_1 = exp1_1.next(); !exp1_1_1.done; exp1_1_1 = exp1_1.next()) {\n        var name_2 = exp1_1_1.value;\n        if (attr1.getExplicit(name_2) !== attr2.getExplicit(name_2)) {\n          return false;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (exp1_1_1 && !exp1_1_1.done && (_a = exp1_1.return)) _a.call(exp1_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return true;\n  };\n  var _cleanSubSup = function (options, low, up) {\n    var e_6, _a;\n    var remove = [];\n    try {\n      for (var _b = __values(options.getList('m' + low + up)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var children = mml.childNodes;\n        if (children[mml[low]] && children[mml[up]]) {\n          continue;\n        }\n        var parent_2 = mml.parent;\n        var newNode = children[mml[low]] ? options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) : options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]);\n        NodeUtil_js_1.default.copyAttributes(mml, newNode);\n        if (parent_2) {\n          parent_2.replaceChild(newNode, mml);\n        } else {\n          options.root = newNode;\n        }\n        remove.push(mml);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n  FilterUtil.cleanSubSup = function (arg) {\n    var options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n  var _moveLimits = function (options, underover, subsup) {\n    var e_7, _a;\n    var remove = [];\n    try {\n      for (var _b = __values(options.getList(underover)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        if (mml.attributes.get('displaystyle')) {\n          continue;\n        }\n        var base = mml.childNodes[mml.base];\n        var mo = base.coreMO();\n        if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n          var node = options.nodeFactory.create('node', subsup, mml.childNodes);\n          NodeUtil_js_1.default.copyAttributes(mml, node);\n          if (mml.parent) {\n            mml.parent.replaceChild(node, mml);\n          } else {\n            options.root = node;\n          }\n          remove.push(mml);\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n  FilterUtil.moveLimits = function (arg) {\n    var options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n  FilterUtil.setInherited = function (arg) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n})(FilterUtil || (FilterUtil = {}));\nexports.default = FilterUtil;","map":{"version":3,"mappings":"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","names":["FilterUtil","arg","options","data","getList","mo","NodeUtil_js_1","getProperty","symbol","getForm","setAttribute","parent_1","parent","getTexClass","texAtom","nodeFactory","create","replaceChild","inheritAttributesFrom","removeProperties","node","root","walkTree","mml","_d","attribs","attributes","keep","Set","get","split","getAllAttributes","getExplicitNames","key","has","getInherited","remove","isType","MmlNode_js_1","REL","m2","children","childNodes","next","indexOf","variantForm","length","_compareExplicit","appendChildren","getChildren","_copyExplicit","getPropertyNames","name_1","setProperty","splice","push","getExplicit","setInherited","getForms","removeFromList","attrs","node1","node2","attr1","attr2","forEach","attr","x","set","filter","space","exp","exp1","exp2","name_2","_cleanSubSup","low","up","parent_2","newNode","base","copyAttributes","error","_moveLimits","underover","subsup","coreMO","setInheritedAttributes","math","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/input/tex/FilterUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Utility functions for standard pre and post filters.\n *\n * @author sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {TEXCLASS, MMLNODE, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport NodeUtil from './NodeUtil.js';\nimport ParseOptions from './ParseOptions.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Attributes} from '../../core/MmlTree/Attributes.js';\n\n\nnamespace FilterUtil {\n\n  /**\n   * Visitor to set stretchy attributes to false on <mo> elements, if they are\n   * not used as delimiters. Also wraps non-stretchy infix delimiters into a\n   * TeXAtom.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanStretchy = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    for (let mo of options.getList('fixStretchy')) {\n      if (NodeUtil.getProperty(mo, 'fixStretchy')) {\n        let symbol = NodeUtil.getForm(mo);\n        if (symbol && symbol[3] && symbol[3]['stretchy']) {\n          NodeUtil.setAttribute(mo, 'stretchy', false);\n        }\n        const parent = mo.parent;\n        if (!NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {\n          const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n          parent.replaceChild(texAtom, mo);\n          texAtom.inheritAttributesFrom(mo);\n        }\n        NodeUtil.removeProperties(mo, 'fixStretchy');\n      }\n    }\n  };\n\n\n  /**\n   * Visitor that removes superfluous attributes from nodes. I.e., if a node has\n   * an attribute, which is also an inherited attribute it will be removed. This\n   * is necessary as attributes are set bottom up in the parser.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanAttributes = function(arg: {data: ParseOptions}) {\n    let node = arg.data.root as MmlNode;\n    node.walkTree((mml: MmlNode, _d: any) => {\n      let attribs = mml.attributes as any;\n      if (!attribs) {\n        return;\n      }\n      const keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));\n      delete (attribs.getAllAttributes())['mjx-keep-attrs'];\n      for (const key of attribs.getExplicitNames()) {\n        if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {\n          delete attribs.attributes[key];\n        }\n      }\n    }, {});\n  };\n\n\n  /**\n   * Combine adjacent <mo> elements that are relations (since MathML treats the\n   * spacing very differently)\n   * @param {ParseOptions} data The parse options.\n   */\n  export let combineRelations = function(arg: {data: ParseOptions}) {\n    const remove: MmlNode[] = [];\n    for (let mo of arg.data.getList('mo')) {\n      if (mo.getProperty('relationsCombined') || !mo.parent ||\n          (mo.parent && !NodeUtil.isType(mo.parent, 'mrow')) ||\n          NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {\n        // @test Prime, PrimeSup, Named Function\n        continue;\n      }\n      let mml = mo.parent;\n      let m2: MmlNode;\n      let children = mml.childNodes as MMLNODE[];\n      let next = children.indexOf(mo) + 1;\n      let variantForm = NodeUtil.getProperty(mo, 'variantForm');\n      while (next < children.length && (m2 = children[next]) &&\n             NodeUtil.isType(m2, 'mo') &&\n             NodeUtil.getTexClass(m2) === TEXCLASS.REL) {\n        if (variantForm === NodeUtil.getProperty(m2, 'variantForm') &&\n            _compareExplicit(mo, m2)) {\n          // @test Shift Left, Less Equal,\n          //       Multirel Font X, Multirel Mathvariant X\n          NodeUtil.appendChildren(mo, NodeUtil.getChildren(m2));\n          // This treatment means we might loose some inheritance structure, but\n          // no properties.\n          _copyExplicit(['stretchy', 'rspace'], mo, m2);\n          for (const name of m2.getPropertyNames()) {\n            mo.setProperty(name, m2.getProperty(name));\n          }\n          children.splice(next, 1);\n          remove.push(m2);\n          m2.parent = null;\n          m2.setProperty('relationsCombined', true);\n        } else {\n          // @test Preset Rspace Lspace\n          if (mo.attributes.getExplicit('rspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(mo, 'rspace', '0pt');\n          }\n          if (m2.attributes.getExplicit('lspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(m2, 'lspace', '0pt');\n          }\n          break;\n        }\n      }\n      mo.attributes.setInherited('form', (mo as MmlMo).getForms()[0]);\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n\n\n  /**\n   * Copies the specified explicit attributes from node2 to node1.\n   * @param {string[]} attrs List of explicit attribute names.\n   * @param {MmlNode} node1 The goal node.\n   * @param {MmlNode} node2 The source node.\n   */\n  let _copyExplicit = function(attrs: string[],\n                               node1: MmlNode, node2: MmlNode) {\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    attrs.forEach(x => {\n      let attr = attr2.getExplicit(x);\n      if (attr != null) {\n        // @test Infix Stretchy Right, Preset Lspace Rspace\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n\n  /**\n   * Compares the explicit attributes of two nodes. Returns true if they\n   * coincide, with the following exceptions:\n   *   - lspace attribute of node1 is ignored.\n   *   - rspace attribute of node2 is ignored.\n   *   - stretchy=false attributes are ignored.\n   * @param {MmlNode} node1 The first node.\n   * @param {MmlNode} node2 Its next sibling.\n   */\n  let _compareExplicit = function(node1: MmlNode, node2: MmlNode) {\n    let filter = (attr: Attributes, space: string): string[] => {\n      let exp = attr.getExplicitNames();\n      return exp.filter(x => {\n        return x !== space &&\n          (x !== 'stretchy' ||\n           attr.getExplicit('stretchy'));\n      });\n    };\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    let exp1 = filter(attr1, 'lspace');\n    let exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    for (let name of exp1) {\n      if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Cleans msubsup and munderover elements.\n   * @param {ParseOptions} options The parse options.\n   * @param {string} low String representing the lower part of the expression.\n   * @param {string} up String representing the upper part.\n   */\n  let _cleanSubSup = function(options: ParseOptions, low: string, up: string) {\n    const remove: MmlNode[] = [];\n    for (let mml of options.getList('m' + low + up) as any[]) {\n      const children = mml.childNodes;\n      if (children[mml[low]] && children[mml[up]]) {\n        continue;\n      }\n      const parent = mml.parent;\n      let newNode = (children[mml[low]] ?\n                 options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :\n                 options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));\n      NodeUtil.copyAttributes(mml, newNode);\n      if (parent) {\n        parent.replaceChild(newNode, mml);\n      } else {\n        options.root = newNode;\n      }\n      remove.push(mml);\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n\n\n  /**\n   * Visitor that rewrites incomplete msubsup/munderover elements in the given\n   * node into corresponding msub/sup/under/over nodes.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanSubSup = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n\n  /**\n   * Looks through the list of munderover elements for ones that have\n   * movablelimits and bases that are not mo's, and creates new msubsup\n   * elements to replace them if they aren't in displaystyle.\n   *\n   * @param {MmlNode} ath The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  let _moveLimits = function (options: ParseOptions, underover: string, subsup: string) {\n    const remove: MmlNode[] = [];\n    for (const mml of options.getList(underover)) {\n      if (mml.attributes.get('displaystyle')) {\n        continue;\n      }\n      const base = mml.childNodes[(mml as any).base] as MmlNode;\n      const mo = base.coreMO();\n      if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n        let node = options.nodeFactory.create('node', subsup, mml.childNodes);\n        NodeUtil.copyAttributes(mml, node);\n        if (mml.parent) {\n          mml.parent.replaceChild(node, mml);\n        } else {\n          options.root = node;\n        }\n        remove.push(mml);\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n\n  /**\n   * Visitor that rewrites in-line munderover elements with movablelimits but bases\n   * that are not mo's into explicit msubsup elements.\n   *\n   * @param {ParseOptions} data  The parse options to use\n   */\n  export let moveLimits = function (arg: {data: ParseOptions}) {\n    const options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n\n  /**\n   * Recursively sets the inherited attributes on the math tree.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let setInherited = function(arg: {math: any, data: ParseOptions}) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n\n}\n\n\nexport default FilterUtil;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}