{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindMathML = void 0;\nvar FindMath_js_1 = require(\"../../core/FindMath.js\");\nvar NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar FindMathML = function (_super) {\n  __extends(FindMathML, _super);\n  function FindMathML() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  FindMathML.prototype.findMath = function (node) {\n    var set = new Set();\n    this.findMathNodes(node, set);\n    this.findMathPrefixed(node, set);\n    var html = this.adaptor.root(this.adaptor.document);\n    if (this.adaptor.kind(html) === 'html' && set.size === 0) {\n      this.findMathNS(node, set);\n    }\n    return this.processMath(set);\n  };\n  FindMathML.prototype.findMathNodes = function (node, set) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(this.adaptor.tags(node, 'math')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var math = _c.value;\n        set.add(math);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  FindMathML.prototype.findMathPrefixed = function (node, set) {\n    var e_2, _a, e_3, _b;\n    var html = this.adaptor.root(this.adaptor.document);\n    try {\n      for (var _c = __values(this.adaptor.allAttributes(html)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var attr = _d.value;\n        if (attr.name.substr(0, 6) === 'xmlns:' && attr.value === NAMESPACE) {\n          var prefix = attr.name.substr(6);\n          try {\n            for (var _e = (e_3 = void 0, __values(this.adaptor.tags(node, prefix + ':math'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var math = _f.value;\n              set.add(math);\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n  FindMathML.prototype.findMathNS = function (node, set) {\n    var e_4, _a;\n    try {\n      for (var _b = __values(this.adaptor.tags(node, 'math', NAMESPACE)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var math = _c.value;\n        set.add(math);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n  FindMathML.prototype.processMath = function (set) {\n    var e_5, _a;\n    var math = [];\n    try {\n      for (var _b = __values(Array.from(set)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var display = this.adaptor.getAttribute(mml, 'display') === 'block' || this.adaptor.getAttribute(mml, 'mode') === 'display';\n        var start = {\n          node: mml,\n          n: 0,\n          delim: ''\n        };\n        var end = {\n          node: mml,\n          n: 0,\n          delim: ''\n        };\n        math.push({\n          math: this.adaptor.outerHTML(mml),\n          start: start,\n          end: end,\n          display: display\n        });\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return math;\n  };\n  FindMathML.OPTIONS = {};\n  return FindMathML;\n}(FindMath_js_1.AbstractFindMath);\nexports.FindMathML = FindMathML;","map":{"version":3,"mappings":"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","names":["NAMESPACE","__extends","FindMathML","node","set","Set","findMathNodes","findMathPrefixed","html","adaptor","root","document","kind","size","findMathNS","processMath","tags","math","add","allAttributes","attr","name","substr","value","prefix","from","mml","display","getAttribute","start","n","delim","end","push","outerHTML","FindMath_js_1","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/input/mathml/FindMathML.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the MathML version of the FindMath object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractFindMath} from '../../core/FindMath.js';\nimport {DOMAdaptor} from '../../core/DOMAdaptor.js';\nimport {OptionList} from '../../util/Options.js';\nimport {ProtoItem} from '../../core/MathItem.js';\n\n/**\n * The MathML namespace\n */\nconst NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\n\n/*****************************************************************/\n/**\n *  Implements the FindMathML object (extends AbstractFindMath)\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class FindMathML<N, T, D> extends AbstractFindMath<N, T, D> {\n\n  /**\n   * @override\n   */\n  public static OPTIONS: OptionList = {};\n\n  /**\n   * The DOMAdaptor for the document being processed\n   */\n  public adaptor: DOMAdaptor<N, T, D>;\n\n  /**\n   * Locates math nodes, possibly with namespace prefixes.\n   *  Store them in a set so that if found more than once, they will only\n   *  appear in the list once.\n   *\n   * @override\n   */\n  public findMath(node: N) {\n    let set = new Set<N>();\n    this.findMathNodes(node, set);\n    this.findMathPrefixed(node, set);\n    const html = this.adaptor.root(this.adaptor.document);\n    if (this.adaptor.kind(html) === 'html' &&  set.size === 0) {\n      this.findMathNS(node, set);\n    }\n    return this.processMath(set);\n  }\n\n  /**\n   * Find plain <math> tags\n   *\n   * @param {N} node       The container to seaerch for math\n   * @param {Set<N>} set   The set in which to store the math nodes\n   */\n  protected findMathNodes(node: N, set: Set<N>) {\n    for (const math of this.adaptor.tags(node, 'math')) {\n      set.add(math);\n    }\n  }\n\n  /**\n   * Find <m:math> tags (or whatever prefixes there are)\n   *\n   * @param {N} node  The container to seaerch for math\n   * @param {NodeSet} set   The set in which to store the math nodes\n   */\n  protected findMathPrefixed(node: N, set: Set<N>) {\n    let html = this.adaptor.root(this.adaptor.document);\n    for (const attr of this.adaptor.allAttributes(html)) {\n      if (attr.name.substr(0, 6) === 'xmlns:' && attr.value === NAMESPACE) {\n        let prefix = attr.name.substr(6);\n        for (const math of this.adaptor.tags(node, prefix + ':math')) {\n          set.add(math);\n        }\n      }\n    }\n  }\n\n  /**\n   * Find namespaced math in XHTML documents (is this really needed?)\n   *\n   * @param {N} node  The container to seaerch for math\n   * @param {NodeSet} set   The set in which to store the math nodes\n   */\n  protected findMathNS(node: N, set: Set<N>) {\n    for (const math of this.adaptor.tags(node, 'math', NAMESPACE)) {\n      set.add(math);\n    }\n  }\n\n  /**\n   *  Produce the array of proto math items from the node set\n   */\n  protected processMath(set: Set<N>) {\n    let math: ProtoItem<N, T>[] = [];\n    for (const mml of Array.from(set)) {\n      let display = (this.adaptor.getAttribute(mml, 'display') === 'block' ||\n                     this.adaptor.getAttribute(mml, 'mode') === 'display');\n      let start = {node: mml, n: 0, delim: ''};\n      let end   = {node: mml, n: 0, delim: ''};\n      math.push({math: this.adaptor.outerHTML(mml), start, end, display});\n    }\n    return math;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}