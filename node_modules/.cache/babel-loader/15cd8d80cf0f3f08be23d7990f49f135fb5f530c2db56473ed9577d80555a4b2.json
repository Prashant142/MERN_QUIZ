{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonScriptbaseMixin = void 0;\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nfunction CommonScriptbaseMixin(Base) {\n  var _a;\n  return _a = function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n      _this.baseScale = 1;\n      _this.baseIc = 0;\n      _this.baseRemoveIc = false;\n      _this.baseIsChar = false;\n      _this.baseHasAccentOver = null;\n      _this.baseHasAccentUnder = null;\n      _this.isLineAbove = false;\n      _this.isLineBelow = false;\n      _this.isMathAccent = false;\n      var core = _this.baseCore = _this.getBaseCore();\n      if (!core) return _this;\n      _this.setBaseAccentsFor(core);\n      _this.baseScale = _this.getBaseScale();\n      _this.baseIc = _this.getBaseIc();\n      _this.baseIsChar = _this.isCharBase();\n      _this.isMathAccent = _this.baseIsChar && _this.scriptChild && !!_this.scriptChild.coreMO().node.getProperty('mathaccent');\n      _this.checkLineAccents();\n      _this.baseRemoveIc = !_this.isLineAbove && !_this.isLineBelow && (!_this.constructor.useIC || _this.isMathAccent);\n      return _this;\n    }\n    Object.defineProperty(class_1.prototype, \"baseChild\", {\n      get: function () {\n        return this.childNodes[this.node.base];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(class_1.prototype, \"scriptChild\", {\n      get: function () {\n        return this.childNodes[1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    class_1.prototype.getBaseCore = function () {\n      var core = this.getSemanticBase() || this.childNodes[0];\n      while (core && (core.childNodes.length === 1 && (core.node.isKind('mrow') || core.node.isKind('TeXAtom') && core.node.texClass !== MmlNode_js_1.TEXCLASS.VCENTER || core.node.isKind('mstyle') || core.node.isKind('mpadded') || core.node.isKind('mphantom') || core.node.isKind('semantics')) || core.node.isKind('munderover') && core.isMathAccent)) {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    };\n    class_1.prototype.setBaseAccentsFor = function (core) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    };\n    class_1.prototype.getSemanticBase = function () {\n      var fence = this.node.attributes.getExplicit('data-semantic-fencepointer');\n      return this.getBaseFence(this.baseChild, fence);\n    };\n    class_1.prototype.getBaseFence = function (fence, id) {\n      var e_1, _a;\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      try {\n        for (var _b = __values(fence.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          var result = this.getBaseFence(child, id);\n          if (result) {\n            return result;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return null;\n    };\n    class_1.prototype.getBaseScale = function () {\n      var child = this.baseCore;\n      var scale = 1;\n      while (child && child !== this) {\n        var bbox = child.getOuterBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    };\n    class_1.prototype.getBaseIc = function () {\n      return this.baseCore.getOuterBBox().ic * this.baseScale;\n    };\n    class_1.prototype.getAdjustedIc = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    };\n    class_1.prototype.isCharBase = function () {\n      var base = this.baseCore;\n      return (base.node.isKind('mo') && base.size === null || base.node.isKind('mi') || base.node.isKind('mn')) && base.bbox.rscale === 1 && Array.from(base.getText()).length === 1;\n    };\n    class_1.prototype.checkLineAccents = function () {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        var mml = this;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    };\n    class_1.prototype.isLineAccent = function (script) {\n      var node = script.coreMO().node;\n      return node.isToken && node.getText() === '\\u2015';\n    };\n    class_1.prototype.getBaseWidth = function () {\n      var bbox = this.baseChild.getOuterBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    };\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n      var w = this.getBaseWidth();\n      var _a = __read(this.getOffset(), 2),\n        x = _a[0],\n        y = _a[1];\n      bbox.append(this.baseChild.getOuterBBox());\n      bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    };\n    class_1.prototype.getOffset = function () {\n      return [0, 0];\n    };\n    class_1.prototype.baseCharZero = function (n) {\n      var largeop = !!this.baseCore.node.attributes.get('largeop');\n      var scale = this.baseScale;\n      return this.baseIsChar && !largeop && scale === 1 ? 0 : n;\n    };\n    class_1.prototype.getV = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      var sbox = this.scriptChild.getOuterBBox();\n      var tex = this.font.params;\n      var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - 4 / 5 * tex.x_height);\n    };\n    class_1.prototype.getU = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      var sbox = this.scriptChild.getOuterBBox();\n      var tex = this.font.params;\n      var attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      var prime = this.node.getProperty('texprimestyle');\n      var p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;\n      var superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + 1 / 4 * tex.x_height);\n    };\n    class_1.prototype.hasMovableLimits = function () {\n      var display = this.node.attributes.get('displaystyle');\n      var mo = this.baseChild.coreMO().node;\n      return !display && !!mo.attributes.get('movablelimits');\n    };\n    class_1.prototype.getOverKU = function (basebox, overbox) {\n      var accent = this.node.attributes.get('accent');\n      var tex = this.font.params;\n      var d = overbox.d * overbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentOver ? t : 0;\n      var T = this.isLineAbove ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    };\n    class_1.prototype.getUnderKV = function (basebox, underbox) {\n      var accent = this.node.attributes.get('accentunder');\n      var tex = this.font.params;\n      var h = underbox.h * underbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentUnder ? t : 0;\n      var T = this.isLineBelow ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    };\n    class_1.prototype.getDeltaW = function (boxes, delta) {\n      var e_2, _a, e_3, _b;\n      if (delta === void 0) {\n        delta = [0, 0, 0];\n      }\n      var align = this.node.attributes.get('align');\n      var widths = boxes.map(function (box) {\n        return box.w * box.rscale;\n      });\n      widths[0] -= this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0;\n      var w = Math.max.apply(Math, __spreadArray([], __read(widths), false));\n      var dw = [];\n      var m = 0;\n      try {\n        for (var _c = __values(widths.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var i = _d.value;\n          dw[i] = (align === 'center' ? (w - widths[i]) / 2 : align === 'right' ? w - widths[i] : 0) + delta[i];\n          if (dw[i] < m) {\n            m = -dw[i];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      if (m) {\n        try {\n          for (var _e = __values(dw.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var i = _f.value;\n            dw[i] += m;\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n      [1, 2].map(function (i) {\n        return dw[i] += boxes[i] ? boxes[i].dx * boxes[0].scale : 0;\n      });\n      return dw;\n    };\n    class_1.prototype.getDelta = function (noskew) {\n      if (noskew === void 0) {\n        noskew = false;\n      }\n      var accent = this.node.attributes.get('accent');\n      var _a = this.baseCore.getOuterBBox(),\n        sk = _a.sk,\n        ic = _a.ic;\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    };\n    class_1.prototype.stretchChildren = function () {\n      var e_4, _a, e_5, _b, e_6, _c;\n      var stretchy = [];\n      try {\n        for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var child = _e.value;\n          if (child.canStretch(2)) {\n            stretchy.push(child);\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n      var count = stretchy.length;\n      var nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        var W = 0;\n        var all = count > 1 && count === nodeCount;\n        try {\n          for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            var noStretch = child.stretch.dir === 0;\n            if (all || noStretch) {\n              var _h = child.getOuterBBox(noStretch),\n                w = _h.w,\n                rscale = _h.rscale;\n              if (w * rscale > W) W = w * rscale;\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n        try {\n          for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {\n            var child = stretchy_1_1.value;\n            child.coreMO().getStretchedVariant([W / child.bbox.rscale]);\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    };\n    return class_1;\n  }(Base), _a.useIC = true, _a;\n}\nexports.CommonScriptbaseMixin = CommonScriptbaseMixin;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AAqOA,SAAgBA,qBAAqB,CAGnCC,IAAO;;EAEP;IAAqBC;IAkEnB;MAAY;WAAA,UAAc,EAAdC,qBAAc,EAAdA,IAAc;QAAdC;;MAAZ,wDACWA,IAAI;MApDRC,eAAS,GAAW,CAAC;MAKrBA,YAAM,GAAW,CAAC;MAKlBA,kBAAY,GAAY,KAAK;MAK7BA,gBAAU,GAAY,KAAK;MAK3BA,uBAAiB,GAAY,IAAI;MACjCA,wBAAkB,GAAY,IAAI;MAKlCA,iBAAW,GAAY,KAAK;MAC5BA,iBAAW,GAAY,KAAK;MAK5BA,kBAAY,GAAY,KAAK;MAwBlC,IAAMC,IAAI,GAAGD,KAAI,CAACE,QAAQ,GAAGF,KAAI,CAACG,WAAW,EAAE;MAC/C,IAAI,CAACF,IAAI;MAITD,KAAI,CAACI,iBAAiB,CAACH,IAAI,CAAC;MAC5BD,KAAI,CAACK,SAAS,GAAGL,KAAI,CAACM,YAAY,EAAE;MACpCN,KAAI,CAACO,MAAM,GAAGP,KAAI,CAACQ,SAAS,EAAE;MAC9BR,KAAI,CAACS,UAAU,GAAGT,KAAI,CAACU,UAAU,EAAE;MAInCV,KAAI,CAACW,YAAY,GAAGX,KAAI,CAACS,UAAU,IAChCT,KAAI,CAACY,WAAW,IAAI,CAAC,CAACZ,KAAI,CAACY,WAAW,CAACC,MAAM,EAAE,CAACC,IAAI,CAACC,WAAW,CAAC,YAAY,CAAa;MAI7Ff,KAAI,CAACgB,gBAAgB,EAAE;MAIvBhB,KAAI,CAACiB,YAAY,GAAG,CAACjB,KAAI,CAACkB,WAAW,IAAI,CAAClB,KAAI,CAACmB,WAAW,KACvD,CAAEnB,KAAI,CAACoB,WAAqC,CAACC,KAAK,IAAIrB,KAAI,CAACW,YAAY,CAAC;;IAC7E;IA1CAW,sBAAWC,8BAAS;WAApB;QACE,OAAO,IAAI,CAACC,UAAU,CAAE,IAAI,CAACV,IAAmB,CAACW,IAAI,CAAC;MACxD,CAAC;;;;IAKDH,sBAAWC,gCAAW;WAAtB;QACE,OAAO,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;MAC3B,CAAC;;;;IA2CMD,6BAAW,GAAlB;MACE,IAAItB,IAAI,GAAG,IAAI,CAACyB,eAAe,EAAE,IAAI,IAAI,CAACF,UAAU,CAAC,CAAC,CAAC;MACvD,OAAOvB,IAAI,KACFA,IAAI,CAACuB,UAAU,CAACG,MAAM,KAAK,CAAC,KAC3B1B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,MAAM,CAAC,IACvB3B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,SAAS,CAAC,IAAI3B,IAAI,CAACa,IAAI,CAACe,QAAQ,KAAKC,qBAAQ,CAACC,OAAQ,IACxE9B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,QAAQ,CAAC,IAAI3B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,SAAS,CAAC,IACzD3B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,UAAU,CAAC,IAAI3B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,WAAW,CAAC,CAAC,IAC/D3B,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,YAAY,CAAC,IAAI3B,IAAI,CAACU,YAAa,CAAC,EAAG;QAC/D,IAAI,CAACP,iBAAiB,CAACH,IAAI,CAAC;QAC5BA,IAAI,GAAGA,IAAI,CAACuB,UAAU,CAAC,CAAC,CAAC;;MAE3B,IAAI,CAACvB,IAAI,EAAE;QACT,IAAI,CAAC+B,iBAAiB,GAAG,IAAI,CAACC,kBAAkB,GAAG,KAAK;;MAE1D,OAAOhC,IAAI,IAAI,IAAI,CAACuB,UAAU,CAAC,CAAC,CAAC;IACnC,CAAC;IAKMD,mCAAiB,GAAxB,UAAyBtB,IAAO;MAC9B,IAAIA,IAAI,CAACa,IAAI,CAACc,MAAM,CAAC,YAAY,CAAC,EAAE;QAClC,IAAI,IAAI,CAACI,iBAAiB,KAAK,IAAI,EAAE;UACnC,IAAI,CAACA,iBAAiB,GAAG,CAAC,CAAC/B,IAAI,CAACa,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,QAAQ,CAAC;;QAE/D,IAAI,IAAI,CAACF,kBAAkB,KAAK,IAAI,EAAE;UACpC,IAAI,CAACA,kBAAkB,GAAG,CAAC,CAAChC,IAAI,CAACa,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,aAAa,CAAC;;;IAGzE,CAAC;IAKMZ,iCAAe,GAAtB;MACE,IAAIa,KAAK,GAAG,IAAI,CAACtB,IAAI,CAACoB,UAAU,CAACG,WAAW,CAAC,4BAA4B,CAAW;MACpF,OAAO,IAAI,CAACC,YAAY,CAAC,IAAI,CAACC,SAAS,EAAEH,KAAK,CAAC;IACjD,CAAC;IASMb,8BAAY,GAAnB,UAAoBa,KAAQ,EAAEI,EAAU;;MACtC,IAAI,CAACJ,KAAK,IAAI,CAACA,KAAK,CAACtB,IAAI,CAACoB,UAAU,IAAI,CAACM,EAAE,EAAE;QAC3C,OAAO,IAAI;;MAEb,IAAIJ,KAAK,CAACtB,IAAI,CAACoB,UAAU,CAACG,WAAW,CAAC,kBAAkB,CAAC,KAAKG,EAAE,EAAE;QAChE,OAAOJ,KAAK;;;QAEd,KAAoB,uBAAK,CAACZ,UAAU,6CAAE;UAAjC,IAAMiB,KAAK;UACd,IAAMC,MAAM,GAAG,IAAI,CAACJ,YAAY,CAACG,KAAK,EAAED,EAAE,CAAC;UAC3C,IAAIE,MAAM,EAAE;YACV,OAAOA,MAAM;;;;;;;;;;;;;;MAGjB,OAAO,IAAI;IACb,CAAC;IAKMnB,8BAAY,GAAnB;MACE,IAAIkB,KAAK,GAAG,IAAI,CAACvC,QAAe;MAChC,IAAIyC,KAAK,GAAG,CAAC;MACb,OAAOF,KAAK,IAAIA,KAAK,KAAK,IAAI,EAAE;QAC9B,IAAMG,IAAI,GAAGH,KAAK,CAACI,YAAY,EAAE;QACjCF,KAAK,IAAIC,IAAI,CAACE,MAAM;QACpBL,KAAK,GAAGA,KAAK,CAACM,MAAM;;MAEtB,OAAOJ,KAAK;IACd,CAAC;IAKMpB,2BAAS,GAAhB;MACE,OAAO,IAAI,CAACrB,QAAQ,CAAC2C,YAAY,EAAE,CAACG,EAAE,GAAG,IAAI,CAAC3C,SAAS;IACzD,CAAC;IAKMkB,+BAAa,GAApB;MACE,IAAMqB,IAAI,GAAG,IAAI,CAAC1C,QAAQ,CAAC2C,YAAY,EAAE;MACzC,OAAO,CAACD,IAAI,CAACI,EAAE,GAAG,IAAI,GAAGJ,IAAI,CAACI,EAAE,GAAG,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC3C,SAAS;IAC9D,CAAC;IAKMkB,4BAAU,GAAjB;MACE,IAAIE,IAAI,GAAG,IAAI,CAACvB,QAAQ;MACxB,OAAQ,CAAEuB,IAAI,CAACX,IAAI,CAACc,MAAM,CAAC,IAAI,CAAC,IAAKH,IAAY,CAACwB,IAAI,KAAK,IAAI,IACtDxB,IAAI,CAACX,IAAI,CAACc,MAAM,CAAC,IAAI,CAAC,IAAIH,IAAI,CAACX,IAAI,CAACc,MAAM,CAAC,IAAI,CAAC,KACjDH,IAAI,CAACmB,IAAI,CAACE,MAAM,KAAK,CAAC,IAAII,KAAK,CAACC,IAAI,CAAC1B,IAAI,CAAC2B,OAAO,EAAE,CAAC,CAACzB,MAAM,KAAK,CAAC;IAC3E,CAAC;IAKMJ,kCAAgB,GAAvB;MACE,IAAI,CAAC,IAAI,CAACT,IAAI,CAACc,MAAM,CAAC,YAAY,CAAC,EAAE;MACrC,IAAI,IAAI,CAACd,IAAI,CAACc,MAAM,CAAC,OAAO,CAAC,EAAE;QAC7B,IAAI,CAACV,WAAW,GAAG,IAAI,CAACmC,YAAY,CAAC,IAAI,CAACzC,WAAW,CAAC;OACvD,MAAM,IAAI,IAAI,CAACE,IAAI,CAACc,MAAM,CAAC,QAAQ,CAAC,EAAE;QACrC,IAAI,CAACT,WAAW,GAAG,IAAI,CAACkC,YAAY,CAAC,IAAI,CAACzC,WAAW,CAAC;OACvD,MAAM;QACL,IAAM0C,GAAG,GAAG,IAAsC;QAClD,IAAI,CAACpC,WAAW,GAAG,IAAI,CAACmC,YAAY,CAACC,GAAG,CAACC,SAAS,CAAC;QACnD,IAAI,CAACpC,WAAW,GAAG,IAAI,CAACkC,YAAY,CAACC,GAAG,CAACE,UAAU,CAAC;;IAExD,CAAC;IAMMjC,8BAAY,GAAnB,UAAoBkC,MAAS;MAC3B,IAAM3C,IAAI,GAAG2C,MAAM,CAAC5C,MAAM,EAAE,CAACC,IAAI;MACjC,OAAQA,IAAI,CAAC4C,OAAO,IAAK5C,IAAc,CAACsC,OAAO,EAAE,KAAK,QAAQ;IAChE,CAAC;IAUM7B,8BAAY,GAAnB;MACE,IAAMqB,IAAI,GAAG,IAAI,CAACL,SAAS,CAACM,YAAY,EAAE;MAC1C,OAAOD,IAAI,CAACe,CAAC,GAAGf,IAAI,CAACE,MAAM,IAAI,IAAI,CAAC7B,YAAY,GAAG,IAAI,CAACV,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACqD,IAAI,CAACC,MAAM,CAACC,QAAQ;IACjG,CAAC;IAQMvC,6BAAW,GAAlB,UAAmBqB,IAAU,EAAEmB,SAA0B;MAA1B;QAAAA,iBAA0B;MAAA;MACvD,IAAMJ,CAAC,GAAG,IAAI,CAACK,YAAY,EAAE;MACvB,gBAAS,IAAI,CAACC,SAAS,EAAE;QAAxBC,CAAC;QAAEC,CAAC,QAAoB;MAC/BvB,IAAI,CAACwB,MAAM,CAAC,IAAI,CAAC7B,SAAS,CAACM,YAAY,EAAE,CAAC;MAC1CD,IAAI,CAACyB,OAAO,CAAC,IAAI,CAACzD,WAAW,CAACiC,YAAY,EAAE,EAAEc,CAAC,GAAGO,CAAC,EAAEC,CAAC,CAAC;MACvDvB,IAAI,CAACe,CAAC,IAAI,IAAI,CAACC,IAAI,CAACC,MAAM,CAACS,WAAW;MACtC1B,IAAI,CAAC2B,KAAK,EAAE;MACZ,IAAI,CAACC,eAAe,CAACT,SAAS,CAAC;IACjC,CAAC;IAOMxC,2BAAS,GAAhB;MACE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IACf,CAAC;IAMMA,8BAAY,GAAnB,UAAoBkD,CAAS;MAC3B,IAAMC,OAAO,GAAG,CAAC,CAAC,IAAI,CAACxE,QAAQ,CAACY,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,SAAS,CAAC;MAC9D,IAAMQ,KAAK,GAAG,IAAI,CAACtC,SAAS;MAC5B,OAAQ,IAAI,CAACI,UAAU,IAAI,CAACiE,OAAO,IAAI/B,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG8B,CAAC;IAC5D,CAAC;IAOMlD,sBAAI,GAAX;MACE,IAAMqB,IAAI,GAAG,IAAI,CAAC1C,QAAQ,CAAC2C,YAAY,EAAE;MACzC,IAAM8B,IAAI,GAAG,IAAI,CAAC/D,WAAW,CAACiC,YAAY,EAAE;MAC5C,IAAM+B,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACC,MAAM;MAC5B,IAAMgB,cAAc,GAAG,IAAI,CAACC,SAAS,CAAC,IAAI,CAAChE,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,gBAAgB,CAAC,EAAEyC,GAAG,CAACG,IAAI,CAAC;MAC3F,OAAOC,IAAI,CAACC,GAAG,CACb,IAAI,CAACC,YAAY,CAACtC,IAAI,CAACuC,CAAC,GAAG,IAAI,CAAC9E,SAAS,GAAGuE,GAAG,CAACQ,QAAQ,GAAGT,IAAI,CAAC7B,MAAM,CAAC,EACvE+B,cAAc,EACdF,IAAI,CAACU,CAAC,GAAGV,IAAI,CAAC7B,MAAM,GAAI,CAAC,GAAG,CAAC,GAAI8B,GAAG,CAACU,QAAQ,CAC9C;IACH,CAAC;IAOM/D,sBAAI,GAAX;MACE,IAAMqB,IAAI,GAAG,IAAI,CAAC1C,QAAQ,CAAC2C,YAAY,EAAE;MACzC,IAAM8B,IAAI,GAAG,IAAI,CAAC/D,WAAW,CAACiC,YAAY,EAAE;MAC5C,IAAM+B,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACC,MAAM;MAC5B,IAAM0B,IAAI,GAAG,IAAI,CAACzE,IAAI,CAACoB,UAAU,CAACsD,OAAO,CAAC,cAAc,EAAE,kBAAkB,CAAC;MAC7E,IAAMC,KAAK,GAAG,IAAI,CAAC3E,IAAI,CAACC,WAAW,CAAC,eAAe,CAAC;MACpD,IAAM2E,CAAC,GAAGD,KAAK,GAAGb,GAAG,CAACe,IAAI,GAAIJ,IAAI,CAACK,YAAY,GAAGhB,GAAG,CAACiB,IAAI,GAAGjB,GAAG,CAACkB,IAAK;MACtE,IAAMC,gBAAgB,GAAG,IAAI,CAACjB,SAAS,CAACS,IAAI,CAACQ,gBAAgB,EAAEL,CAAC,CAAC;MACjE,OAAOV,IAAI,CAACC,GAAG,CACb,IAAI,CAACC,YAAY,CAACtC,IAAI,CAACyC,CAAC,GAAG,IAAI,CAAChF,SAAS,GAAGuE,GAAG,CAACoB,QAAQ,GAAGrB,IAAI,CAAC7B,MAAM,CAAC,EACvEiD,gBAAgB,EAChBpB,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAAC7B,MAAM,GAAI,CAAC,GAAG,CAAC,GAAI8B,GAAG,CAACU,QAAQ,CAC9C;IACH,CAAC;IAUM/D,kCAAgB,GAAvB;MACE,IAAM0E,OAAO,GAAG,IAAI,CAACnF,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,cAAc,CAAC;MACxD,IAAM+D,EAAE,GAAG,IAAI,CAAC3D,SAAS,CAAC1B,MAAM,EAAE,CAACC,IAAI;MACvC,OAAQ,CAACmF,OAAO,IAAI,CAAC,CAACC,EAAE,CAAChE,UAAU,CAACC,GAAG,CAAC,eAAe,CAAC;IAC1D,CAAC;IASMZ,2BAAS,GAAhB,UAAiB4E,OAAa,EAAEC,OAAa;MAC3C,IAAMC,MAAM,GAAG,IAAI,CAACvF,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,QAAQ,CAAY;MAC5D,IAAMyC,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACC,MAAM;MAC5B,IAAMsB,CAAC,GAAGiB,OAAO,CAACjB,CAAC,GAAGiB,OAAO,CAACtD,MAAM;MACpC,IAAMwD,CAAC,GAAG1B,GAAG,CAAC2B,cAAc,GAAG3B,GAAG,CAAC4B,iBAAiB;MACpD,IAAMC,KAAK,GAAI,IAAI,CAACzE,iBAAiB,GAAGsE,CAAC,GAAG,CAAE;MAC9C,IAAMI,CAAC,GAAI,IAAI,CAACxF,WAAW,GAAG,CAAC,GAAG0D,GAAG,CAAC2B,cAAc,GAAGD,CAAE;MACzD,IAAMK,CAAC,GAAG,CAACN,MAAM,GAAGK,CAAC,GAAG1B,IAAI,CAACC,GAAG,CAACL,GAAG,CAACgC,eAAe,EAAEhC,GAAG,CAACiC,eAAe,GAAG7B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEE,CAAC,CAAC,CAAC,IAAIsB,KAAK;MACpG,OAAO,CAACE,CAAC,EAAER,OAAO,CAACd,CAAC,GAAGc,OAAO,CAACrD,MAAM,GAAG6D,CAAC,GAAGxB,CAAC,CAAC;IAChD,CAAC;IASM5D,4BAAU,GAAjB,UAAkB4E,OAAa,EAAEW,QAAc;MAC7C,IAAMT,MAAM,GAAG,IAAI,CAACvF,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,aAAa,CAAY;MACjE,IAAMyC,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACC,MAAM;MAC5B,IAAMwB,CAAC,GAAGyB,QAAQ,CAACzB,CAAC,GAAGyB,QAAQ,CAAChE,MAAM;MACtC,IAAMwD,CAAC,GAAG1B,GAAG,CAAC2B,cAAc,GAAG3B,GAAG,CAAC4B,iBAAiB;MACpD,IAAMC,KAAK,GAAI,IAAI,CAACxE,kBAAkB,GAAGqE,CAAC,GAAG,CAAE;MAC/C,IAAMI,CAAC,GAAI,IAAI,CAACvF,WAAW,GAAG,CAAC,GAAGyD,GAAG,CAAC2B,cAAc,GAAGD,CAAE;MACzD,IAAMK,CAAC,GAAG,CAACN,MAAM,GAAGK,CAAC,GAAG1B,IAAI,CAACC,GAAG,CAACL,GAAG,CAACmC,eAAe,EAAEnC,GAAG,CAACoC,eAAe,GAAG3B,CAAC,CAAC,IAAIoB,KAAK;MACvF,OAAO,CAACE,CAAC,EAAE,EAAER,OAAO,CAAChB,CAAC,GAAGgB,OAAO,CAACrD,MAAM,GAAG6D,CAAC,GAAGtB,CAAC,CAAC,CAAC;IACnD,CAAC;IAOM9D,2BAAS,GAAhB,UAAiB0F,KAAa,EAAER,KAA2B;;MAA3B;QAAAA,SAAmB,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAAA;MACzD,IAAMS,KAAK,GAAG,IAAI,CAACpG,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,OAAO,CAAC;MAC/C,IAAMgF,MAAM,GAAGF,KAAK,CAACG,GAAG,CAAC,aAAG;QAAI,UAAG,CAACzD,CAAC,GAAG0D,GAAG,CAACvE,MAAM;MAAlB,CAAkB,CAAC;MACnDqE,MAAM,CAAC,CAAC,CAAC,IAAK,IAAI,CAAClG,YAAY,IAAI,CAAC,IAAI,CAACf,QAAQ,CAACY,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC5B,MAAM,GAAG,CAAE;MACnG,IAAMoD,CAAC,GAAGqB,IAAI,CAACC,GAAG,OAARD,IAAI,2BAAQmC,MAAM,UAAC;MAC7B,IAAMG,EAAE,GAAG,EAAc;MACzB,IAAIC,CAAC,GAAG,CAAC;;QACT,KAAgB,wBAAM,CAACC,IAAI,EAAE,6CAAE;UAA1B,IAAMC,CAAC;UACVH,EAAE,CAACG,CAAC,CAAC,GAAG,CAACP,KAAK,KAAK,QAAQ,GAAG,CAACvD,CAAC,GAAGwD,MAAM,CAACM,CAAC,CAAC,IAAI,CAAC,GACxCP,KAAK,KAAK,OAAO,GAAGvD,CAAC,GAAGwD,MAAM,CAACM,CAAC,CAAC,GAAG,CAAC,IAAIhB,KAAK,CAACgB,CAAC,CAAC;UAC1D,IAAIH,EAAE,CAACG,CAAC,CAAC,GAAGF,CAAC,EAAE;YACbA,CAAC,GAAG,CAACD,EAAE,CAACG,CAAC,CAAC;;;;;;;;;;;;;;MAGd,IAAIF,CAAC,EAAE;;UACL,KAAgB,oBAAE,CAACC,IAAI,EAAE,6CAAE;YAAtB,IAAMC,CAAC;YACVH,EAAE,CAACG,CAAC,CAAC,IAAIF,CAAC;;;;;;;;;;;;;;MAGd,CAAC,CAAC,EAAE,CAAC,CAAC,CAACH,GAAG,CAAC,WAAC;QAAI,SAAE,CAACK,CAAC,CAAC,IAAKR,KAAK,CAACQ,CAAC,CAAC,GAAGR,KAAK,CAACQ,CAAC,CAAC,CAACC,EAAE,GAAGT,KAAK,CAAC,CAAC,CAAC,CAACtE,KAAK,GAAG,CAAE;MAAtD,CAAsD,CAAC;MACvE,OAAO2E,EAAE;IACX,CAAC;IAMM/F,0BAAQ,GAAf,UAAgBoG,MAAuB;MAAvB;QAAAA,cAAuB;MAAA;MACrC,IAAMtB,MAAM,GAAG,IAAI,CAACvF,IAAI,CAACoB,UAAU,CAACC,GAAG,CAAC,QAAQ,CAAC;MAC3C,SAAW,IAAI,CAACjC,QAAQ,CAAC2C,YAAY,EAAE;QAAtC+E,EAAE;QAAE5E,EAAE,QAAgC;MAC7C,OAAO,CAAC,CAACqD,MAAM,IAAI,CAACsB,MAAM,GAAGC,EAAE,GAAG,CAAC,IAAI,IAAI,CAAChE,IAAI,CAACiE,YAAY,GAAG7E,EAAE,IAAI,IAAI,CAAC3C,SAAS;IACtF,CAAC;IAMMkB,iCAAe,GAAtB;;MACE,IAAIuG,QAAQ,GAAiB,EAAE;;QAI/B,KAAoB,sBAAI,CAACtG,UAAU,6CAAE;UAAhC,IAAMiB,KAAK;UACd,IAAIA,KAAK,CAACsF,UAAU,GAAsB,EAAE;YAC1CD,QAAQ,CAACE,IAAI,CAACvF,KAAK,CAAC;;;;;;;;;;;;;;MAGxB,IAAIwF,KAAK,GAAGH,QAAQ,CAACnG,MAAM;MAC3B,IAAIuG,SAAS,GAAG,IAAI,CAAC1G,UAAU,CAACG,MAAM;MACtC,IAAIsG,KAAK,IAAIC,SAAS,GAAG,CAAC,EAAE;QAC1B,IAAIC,CAAC,GAAG,CAAC;QAKT,IAAIC,GAAG,GAAIH,KAAK,GAAG,CAAC,IAAIA,KAAK,KAAKC,SAAU;;UAC5C,KAAoB,sBAAI,CAAC1G,UAAU,6CAAE;YAAhC,IAAMiB,KAAK;YACd,IAAM4F,SAAS,GAAI5F,KAAK,CAAC6F,OAAO,CAACC,GAAG,MAAoB;YACxD,IAAIH,GAAG,IAAIC,SAAS,EAAE;cACd,SAAc5F,KAAK,CAACI,YAAY,CAACwF,SAAS,CAAC;gBAA1C1E,CAAC;gBAAEb,MAAM,YAAiC;cACjD,IAAIa,CAAC,GAAGb,MAAM,GAAGqF,CAAC,EAAEA,CAAC,GAAGxE,CAAC,GAAGb,MAAM;;;;;;;;;;;;;;;UAMtC,KAAoB,kCAAQ,2FAAE;YAAzB,IAAML,KAAK;YACbA,KAAK,CAAC5B,MAAM,EAAe,CAAC2H,mBAAmB,CAAC,CAACL,CAAC,GAAG1F,KAAK,CAACG,IAAI,CAACE,MAAM,CAAC,CAAC;;;;;;;;;;;;;;IAG/E,CAAC;IAEH,cAAC;EAAD,CAAC,CA3boBlD,IAAI,GAKT6I,QAAK,GAAY,IAAK;AAwbxC;AAlcAC","names":["CommonScriptbaseMixin","Base","__extends","_i","args","_this","core","baseCore","getBaseCore","setBaseAccentsFor","baseScale","getBaseScale","baseIc","getBaseIc","baseIsChar","isCharBase","isMathAccent","scriptChild","coreMO","node","getProperty","checkLineAccents","baseRemoveIc","isLineAbove","isLineBelow","constructor","useIC","Object","class_1","childNodes","base","getSemanticBase","length","isKind","texClass","MmlNode_js_1","VCENTER","baseHasAccentOver","baseHasAccentUnder","attributes","get","fence","getExplicit","getBaseFence","baseChild","id","child","result","scale","bbox","getOuterBBox","rscale","parent","ic","size","Array","from","getText","isLineAccent","mml","overChild","underChild","script","isToken","w","font","params","extra_ic","recompute","getBaseWidth","getOffset","x","y","append","combine","scriptspace","clean","setChildPWidths","n","largeop","sbox","tex","subscriptshift","length2em","sub1","Math","max","baseCharZero","d","sub_drop","h","x_height","attr","getList","prime","p","sup3","displaystyle","sup1","sup2","superscriptshift","sup_drop","display","mo","basebox","overbox","accent","t","rule_thickness","separation_factor","delta","T","k","big_op_spacing1","big_op_spacing3","underbox","big_op_spacing2","big_op_spacing4","boxes","align","widths","map","box","dw","m","keys","i","dx","noskew","sk","skewIcFactor","stretchy","canStretch","push","count","nodeCount","W","all","noStretch","stretch","dir","getStretchedVariant","_a","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/output/common/Wrappers/scriptbase.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the a base mixin for CommonMsubsup, CommonMunderover\n *                and their relatives.  (Since munderover can become msubsup\n *                when movablelimits is set, munderover needs to be able to\n *                do the same thing as msubsup in some cases.)\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport {CommonMo} from './mo.js';\nimport {CommonMunderover} from './munderover.js';\nimport {TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMo} from '../../../core/MmlTree/MmlNodes/mo.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {DIRECTION} from '../FontData.js';\n\n/*****************************************************************/\n/**\n * The CommonScriptbase interface\n *\n * @template W  The child-node Wrapper class\n */\nexport interface CommonScriptbase<W extends AnyWrapper> extends AnyWrapper {\n\n  /**\n   * The core mi or mo of the base (or the base itself if there isn't one)\n   */\n  readonly baseCore: W;\n\n  /**\n   * The base element's wrapper\n   */\n  readonly baseChild: W;\n\n  /**\n   * The relative scaling of the base compared to the munderover/msubsup\n   */\n  readonly baseScale: number;\n\n  /**\n   * The italic correction of the base (if any)\n   */\n  readonly baseIc: number;\n\n  /**\n   * True if base italic correction should be removed (msub and msubsup or mathaccents)\n   */\n  readonly baseRemoveIc: boolean;\n\n  /**\n   * True if the base is a single character\n   */\n  readonly baseIsChar: boolean;\n\n  /**\n   * True if the base has an accent under or over\n   */\n  readonly baseHasAccentOver: boolean;\n  readonly baseHasAccentUnder: boolean;\n\n  /**\n   * True if this is an overline or underline\n   */\n  readonly isLineAbove: boolean;\n  readonly isLineBelow: boolean;\n\n  /**\n   * True if this is an msup with script that is a math accent\n   */\n  readonly isMathAccent: boolean;\n\n  /**\n   * The script element's wrapper (overridden in subclasses)\n   */\n  readonly scriptChild: W;\n\n  /***************************************************************************/\n  /*\n   *  Methods for information about the core element for the base\n   */\n\n  /**\n   * @return {W}    The wrapper for the base core mi or mo (or whatever)\n   */\n  getBaseCore(): W;\n\n  /**\n   * @return {W}    The base fence item or null\n   */\n  getSemanticBase(): W;\n\n  /**\n   * Recursively retrieves an element for a given fencepointer.\n   *\n   * @param {W} fence The potential fence.\n   * @param {string} id The fencepointer id.\n   * @return {W} The original fence the scripts belong to.\n   */\n  getBaseFence(fence: W, id: string): W;\n\n  /**\n   * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n   */\n  getBaseScale(): number;\n\n  /**\n   * The base's italic correction (properly scaled)\n   */\n  getBaseIc(): number;\n\n  /**\n   * An adjusted italic correction (for slightly better results)\n   */\n  getAdjustedIc(): number;\n\n  /**\n   * @return {boolean}  True if the base is an mi, mn, or mo (not a largeop) consisting of\n   *                    a single unstretched character\n   */\n  isCharBase(): boolean;\n\n  /**\n   * Determine if the under- and overscripts are under- or overlines.\n   */\n  checkLineAccents(): void;\n\n  /**\n   * @param {W} script   The script node to check for being a line\n   */\n  isLineAccent(script: W): boolean;\n\n  /***************************************************************************/\n  /*\n   *  Methods for sub-sup nodes\n   */\n\n  /**\n   * @return {number}    The base child's width without the base italic correction (if not needed)\n   */\n  getBaseWidth(): number;\n\n  /**\n   * Get the shift for the script (implemented in subclasses)\n   *\n   * @return {number[]}   The horizontal and vertical offsets for the script\n   */\n  getOffset(): number[];\n\n  /**\n   * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n   * @return {number}     Either n or 0\n   */\n  baseCharZero(n: number): number;\n\n  /**\n   * Get the shift for a subscript (TeXBook Appendix G 18ab)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getV(): number;\n\n  /**\n   * Get the shift for a superscript (TeXBook Appendix G 18acd)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getU(): number;\n\n  /***************************************************************************/\n  /*\n   *  Methods for under-over nodes\n   */\n\n  /**\n   * @return {boolean}  True if the base has movablelimits (needed by munderover)\n   */\n  hasMovableLimits(): boolean;\n\n  /**\n   * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox  The bounding box of the base\n   * @param {BBox} overbox  The bounding box of the overscript\n   * @return {number[]}     The separation between their boxes, and the offset of the overscript\n   */\n  getOverKU(basebox: BBox, overbox: BBox): number[];\n\n  /**\n   * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox   The bounding box of the base\n   * @param {BBox} underbox  The bounding box of the underscript\n   * @return {number[]}      The separation between their boxes, and the offset of the underscript\n   */\n  getUnderKV(basebox: BBox, underbox: BBox): number[];\n\n  /**\n   * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n   * @param {number[]=} delta  The initial x offsets of the boxes\n   * @return {number[]}        The actual offsets needed to center the boxes in the stack\n   */\n  getDeltaW(boxes: BBox[], delta?: number[]): number[];\n\n  /**\n   * @param {boolean=} noskew   Whether to ignore the skew amount\n   * @return {number}           The offset for under and over\n   */\n  getDelta(noskew?: boolean): number;\n\n  /**\n   * Handle horizontal stretching of children to match greatest width\n   *  of all children\n   */\n  stretchChildren(): void;\n\n}\n\nexport interface CommonScriptbaseClass extends AnyWrapperClass {\n  /**\n   * Set to true for munderover/munder/mover/msup (Appendix G 13)\n   */\n  useIC: boolean;\n}\n\n/**\n * Shorthand for the CommonScriptbase constructor\n *\n * @template W  The child-node Wrapper class\n */\nexport type ScriptbaseConstructor<W extends AnyWrapper> = Constructor<CommonScriptbase<W>>;\n\n/*****************************************************************/\n/**\n * A base class for msup/msub/msubsup and munder/mover/munderover\n * wrapper mixin implementations\n *\n * @template W  The child-node Wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonScriptbaseMixin<\n  W extends AnyWrapper,\n  T extends WrapperConstructor\n>(Base: T): ScriptbaseConstructor<W> & T {\n\n  return class extends Base {\n\n    /**\n     * Set to false for msubsup/msub (Appendix G 13)\n     */\n    public static useIC: boolean = true;\n\n    /**\n     * The core mi or mo of the base (or the base itself if there isn't one)\n     */\n    public baseCore: W;\n\n    /**\n     * The base element's wrapper\n     */\n    public baseScale: number = 1;\n\n    /**\n     * The relative scaling of the base compared to the munderover/msubsup\n     */\n    public baseIc: number = 0;\n\n    /**\n     * True if base italic correction should be removed (msub and msubsup or mathaccents)\n     */\n    public baseRemoveIc: boolean = false;\n\n    /**\n     * True if the base is a single character\n     */\n    public baseIsChar: boolean = false;\n\n    /**\n     * True if the base has an accent under or over\n     */\n    public baseHasAccentOver: boolean = null;\n    public baseHasAccentUnder: boolean = null;\n\n    /**\n     * True if this is an overline or underline\n     */\n    public isLineAbove: boolean = false;\n    public isLineBelow: boolean = false;\n\n    /**\n     * True if this is an msup with script that is a math accent\n     */\n    public isMathAccent: boolean = false;\n\n    /**\n     * @return {W}  The base element's wrapper\n     */\n    public get baseChild(): W {\n      return this.childNodes[(this.node as MmlMsubsup).base];\n    }\n\n    /**\n     * @return {W}  The script element's wrapper (overridden in subclasses)\n     */\n    public get scriptChild(): W {\n      return this.childNodes[1];\n    }\n\n    /**\n     * @override\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      //\n      //  Find the base core\n      //\n      const core = this.baseCore = this.getBaseCore();\n      if (!core) return;\n      //\n      // Get information about the base element\n      //\n      this.setBaseAccentsFor(core);\n      this.baseScale = this.getBaseScale();\n      this.baseIc = this.getBaseIc();\n      this.baseIsChar = this.isCharBase();\n      //\n      //  Determine if we are setting a mathaccent\n      //\n      this.isMathAccent = this.baseIsChar &&\n        (this.scriptChild && !!this.scriptChild.coreMO().node.getProperty('mathaccent')) as boolean;\n      //\n      // Check for overline/underline accents\n      //\n      this.checkLineAccents();\n      //\n      //  Check if the base is a mi or mo that needs italic correction removed\n      //\n      this.baseRemoveIc = !this.isLineAbove && !this.isLineBelow &&\n        (!(this.constructor as CommonScriptbaseClass).useIC || this.isMathAccent);\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for information about the core element for the base\n     */\n\n    /**\n     * @return {W}    The wrapper for the base core mi or mo (or whatever)\n     */\n    public getBaseCore(): W {\n      let core = this.getSemanticBase() || this.childNodes[0];\n      while (core &&\n             ((core.childNodes.length === 1 &&\n               (core.node.isKind('mrow') ||\n                (core.node.isKind('TeXAtom') && core.node.texClass !== TEXCLASS.VCENTER) ||\n                core.node.isKind('mstyle') || core.node.isKind('mpadded') ||\n                core.node.isKind('mphantom') || core.node.isKind('semantics'))) ||\n              (core.node.isKind('munderover') && core.isMathAccent)))  {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    }\n\n    /**\n     * @param {W} core   The element to check for accents\n     */\n    public setBaseAccentsFor(core: W) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    }\n\n    /**\n     * @return {W}    The base fence item or null\n     */\n    public getSemanticBase(): W {\n      let fence = this.node.attributes.getExplicit('data-semantic-fencepointer') as string;\n      return this.getBaseFence(this.baseChild, fence);\n    }\n\n    /**\n     * Recursively retrieves an element for a given fencepointer.\n     *\n     * @param {W} fence The potential fence.\n     * @param {string} id The fencepointer id.\n     * @return {W} The original fence the scripts belong to.\n     */\n    public getBaseFence(fence: W, id: string): W {\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      for (const child of fence.childNodes) {\n        const result = this.getBaseFence(child, id);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n     */\n    public getBaseScale(): number {\n      let child = this.baseCore as any;\n      let scale = 1;\n      while (child && child !== this) {\n        const bbox = child.getOuterBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    }\n\n    /**\n     * The base's italic correction (properly scaled)\n     */\n    public getBaseIc(): number {\n      return this.baseCore.getOuterBBox().ic * this.baseScale;\n    }\n\n    /**\n     * An adjusted italic correction (for slightly better results)\n     */\n    public getAdjustedIc(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    }\n\n    /**\n     * @return {boolean}  True if the base is an mi, mn, or mo consisting of a single character\n     */\n    public isCharBase(): boolean {\n      let base = this.baseCore;\n      return (((base.node.isKind('mo') && (base as any).size === null) ||\n               base.node.isKind('mi') || base.node.isKind('mn')) &&\n              base.bbox.rscale === 1 && Array.from(base.getText()).length === 1);\n    }\n\n    /**\n     * Determine if the under- and overscripts are under- or overlines.\n     */\n    public checkLineAccents() {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        const mml = this as unknown as CommonMunderover<W>;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    }\n\n    /**\n     * @param {W} script   The script node to check for being a line\n     * @return {boolean}   True if the script is U+2015\n     */\n    public isLineAccent(script: W): boolean {\n      const node = script.coreMO().node;\n      return (node.isToken && (node as MmlMo).getText() === '\\u2015');\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for sub-sup nodes\n     */\n\n    /**\n     * @return {number}    The base child's width without the base italic correction (if not needed)\n     */\n    public getBaseWidth(): number {\n      const bbox = this.baseChild.getOuterBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    }\n\n    /**\n     * This gives the common bbox for msub and msup.  It is overridden\n     * for all the others (msubsup, munder, mover, munderover).\n     *\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      const w = this.getBaseWidth();\n      const [x, y] = this.getOffset();\n      bbox.append(this.baseChild.getOuterBBox());\n      bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * Get the shift for the script (implemented in subclasses)\n     *\n     * @return {[number, number]}   The horizontal and vertical offsets for the script\n     */\n    public getOffset(): [number, number] {\n      return [0, 0];\n    }\n\n    /**\n     * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n     * @return {number}     Either n or 0\n     */\n    public baseCharZero(n: number): number {\n      const largeop = !!this.baseCore.node.attributes.get('largeop');\n      const scale = this.baseScale;\n      return (this.baseIsChar && !largeop && scale === 1 ? 0 : n);\n    }\n\n    /**\n     * Get the shift for a subscript (TeXBook Appendix G 18ab)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getV(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      const sbox = this.scriptChild.getOuterBBox();\n      const tex = this.font.params;\n      const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(\n        this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale),\n        subscriptshift,\n        sbox.h * sbox.rscale - (4 / 5) * tex.x_height\n      );\n    }\n\n    /**\n     * Get the shift for a superscript (TeXBook Appendix G 18acd)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getU(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      const sbox = this.scriptChild.getOuterBBox();\n      const tex = this.font.params;\n      const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      const prime = this.node.getProperty('texprimestyle');\n      const p = prime ? tex.sup3 : (attr.displaystyle ? tex.sup1 : tex.sup2);\n      const superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(\n        this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale),\n        superscriptshift,\n        sbox.d * sbox.rscale + (1 / 4) * tex.x_height\n      );\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for under-over nodes\n     */\n\n    /**\n     * @return {boolean}  True if the base has movablelimits (needed by munderover)\n     */\n    public hasMovableLimits(): boolean {\n      const display = this.node.attributes.get('displaystyle');\n      const mo = this.baseChild.coreMO().node;\n      return (!display && !!mo.attributes.get('movablelimits'));\n    }\n\n    /**\n     * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox  The bounding box of the base\n     * @param {BBox} overbox  The bounding box of the overscript\n     * @return {[number, number]}     The separation between their boxes, and the offset of the overscript\n     */\n    public getOverKU(basebox: BBox, overbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accent') as boolean;\n      const tex = this.font.params;\n      const d = overbox.d * overbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentOver ? t : 0);\n      const T = (this.isLineAbove ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    }\n\n    /**\n     * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox   The bounding box of the base\n     * @param {BBox} underbox  The bounding box of the underscript\n     * @return {[number, number]}      The separation between their boxes, and the offset of the underscript\n     */\n    public getUnderKV(basebox: BBox, underbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accentunder') as boolean;\n      const tex = this.font.params;\n      const h = underbox.h * underbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentUnder ? t : 0);\n      const T = (this.isLineBelow ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    }\n\n    /**\n     * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n     * @param {number[]=} delta  The initial x offsets of the boxes\n     * @return {number[]}        The actual offsets needed to center the boxes in the stack\n     */\n    public getDeltaW(boxes: BBox[], delta: number[] = [0, 0, 0]): number[] {\n      const align = this.node.attributes.get('align');\n      const widths = boxes.map(box => box.w * box.rscale);\n      widths[0] -= (this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0);\n      const w = Math.max(...widths);\n      const dw = [] as number[];\n      let m = 0;\n      for (const i of widths.keys()) {\n        dw[i] = (align === 'center' ? (w - widths[i]) / 2 :\n                 align === 'right' ? w - widths[i] : 0) + delta[i];\n        if (dw[i] < m) {\n          m = -dw[i];\n        }\n      }\n      if (m) {\n        for (const i of dw.keys()) {\n          dw[i] += m;\n        }\n      }\n      [1, 2].map(i => dw[i] += (boxes[i] ? boxes[i].dx * boxes[0].scale : 0));\n      return dw;\n    }\n\n    /**\n     * @param {boolean=} noskew   Whether to ignore the skew amount\n     * @return {number}           The offset for under and over\n     */\n    public getDelta(noskew: boolean = false): number {\n      const accent = this.node.attributes.get('accent');\n      const {sk, ic} = this.baseCore.getOuterBBox();\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    }\n\n    /**\n     * Handle horizontal stretching of children to match greatest width\n     *  of all children\n     */\n    public stretchChildren() {\n      let stretchy: AnyWrapper[] = [];\n      //\n      //  Locate and count the stretchy children\n      //\n      for (const child of this.childNodes) {\n        if (child.canStretch(DIRECTION.Horizontal)) {\n          stretchy.push(child);\n        }\n      }\n      let count = stretchy.length;\n      let nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        let W = 0;\n        //\n        //  If all the children are stretchy, find the largest one,\n        //  otherwise, find the width of the non-stretchy children.\n        //\n        let all = (count > 1 && count === nodeCount);\n        for (const child of this.childNodes) {\n          const noStretch = (child.stretch.dir === DIRECTION.None);\n          if (all || noStretch) {\n            const {w, rscale} = child.getOuterBBox(noStretch);\n            if (w * rscale > W) W = w * rscale;\n          }\n        }\n        //\n        //  Stretch the stretchable children\n        //\n        for (const child of stretchy) {\n          (child.coreMO() as CommonMo).getStretchedVariant([W / child.bbox.rscale]);\n        }\n      }\n    }\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}