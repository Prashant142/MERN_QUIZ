{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonMencloseMixin = void 0;\nvar Notation = __importStar(require(\"../Notation.js\"));\nvar string_js_1 = require(\"../../../util/string.js\");\nfunction CommonMencloseMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n      _this.notations = {};\n      _this.renderChild = null;\n      _this.msqrt = null;\n      _this.padding = Notation.PADDING;\n      _this.thickness = Notation.THICKNESS;\n      _this.arrowhead = {\n        x: Notation.ARROWX,\n        y: Notation.ARROWY,\n        dx: Notation.ARROWDX\n      };\n      _this.TRBL = [0, 0, 0, 0];\n      _this.getParameters();\n      _this.getNotations();\n      _this.removeRedundantNotations();\n      _this.initializeNotations();\n      _this.TRBL = _this.getBBoxExtenders();\n      return _this;\n    }\n    class_1.prototype.getParameters = function () {\n      var attributes = this.node.attributes;\n      var padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      var thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      var arrowhead = attributes.get('data-arrowhead');\n      if (arrowhead !== undefined) {\n        var _b = __read((0, string_js_1.split)(arrowhead), 3),\n          x = _b[0],\n          y = _b[1],\n          dx = _b[2];\n        this.arrowhead = {\n          x: x ? parseFloat(x) : Notation.ARROWX,\n          y: y ? parseFloat(y) : Notation.ARROWY,\n          dx: dx ? parseFloat(dx) : Notation.ARROWDX\n        };\n      }\n    };\n    class_1.prototype.getNotations = function () {\n      var e_1, _b;\n      var Notations = this.constructor.notations;\n      try {\n        for (var _c = __values((0, string_js_1.split)(this.node.attributes.get('notation'))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          var notation = Notations.get(name_1);\n          if (notation) {\n            this.notations[name_1] = notation;\n            if (notation.renderChild) {\n              this.renderChild = notation.renderer;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n    class_1.prototype.removeRedundantNotations = function () {\n      var e_2, _b, e_3, _c;\n      try {\n        for (var _d = __values(Object.keys(this.notations)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var name_2 = _e.value;\n          if (this.notations[name_2]) {\n            var remove = this.notations[name_2].remove || '';\n            try {\n              for (var _f = (e_3 = void 0, __values(remove.split(/ /))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var notation = _g.value;\n                delete this.notations[notation];\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n    class_1.prototype.initializeNotations = function () {\n      var e_4, _b;\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_3 = _d.value;\n          var init = this.notations[name_3].init;\n          init && init(this);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    };\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n      var _b = __read(this.TRBL, 4),\n        T = _b[0],\n        R = _b[1],\n        B = _b[2],\n        L = _b[3];\n      var child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    };\n    class_1.prototype.getBBoxExtenders = function () {\n      var e_5, _b;\n      var TRBL = [0, 0, 0, 0];\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_4 = _d.value;\n          this.maximizeEntries(TRBL, this.notations[name_4].bbox(this));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      return TRBL;\n    };\n    class_1.prototype.getPadding = function () {\n      var e_6, _b;\n      var _this = this;\n      var BTRBL = [0, 0, 0, 0];\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_5 = _d.value;\n          var border = this.notations[name_5].border;\n          if (border) {\n            this.maximizeEntries(BTRBL, border(this));\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n      return [0, 1, 2, 3].map(function (i) {\n        return _this.TRBL[i] - BTRBL[i];\n      });\n    };\n    class_1.prototype.maximizeEntries = function (X, Y) {\n      for (var i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    };\n    class_1.prototype.getOffset = function (direction) {\n      var _b = __read(this.TRBL, 4),\n        T = _b[0],\n        R = _b[1],\n        B = _b[2],\n        L = _b[3];\n      var d = (direction === 'X' ? R - L : B - T) / 2;\n      return Math.abs(d) > .001 ? d : 0;\n    };\n    class_1.prototype.getArgMod = function (w, h) {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    };\n    class_1.prototype.arrow = function (_w, _a, _double, _offset, _dist) {\n      if (_offset === void 0) {\n        _offset = '';\n      }\n      if (_dist === void 0) {\n        _dist = 0;\n      }\n      return null;\n    };\n    class_1.prototype.arrowData = function () {\n      var _b = __read([this.padding, this.thickness], 2),\n        p = _b[0],\n        t = _b[1];\n      var r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      var _c = this.childNodes[0].getBBox(),\n        h = _c.h,\n        d = _c.d,\n        w = _c.w;\n      var H = h + d;\n      var R = Math.sqrt(H * H + w * w);\n      var x = Math.max(p, r * w / R);\n      var y = Math.max(p, r * H / R);\n      var _d = __read(this.getArgMod(w + 2 * x, H + 2 * y), 2),\n        a = _d[0],\n        W = _d[1];\n      return {\n        a: a,\n        W: W,\n        x: x,\n        y: y\n      };\n    };\n    class_1.prototype.arrowAW = function () {\n      var _b = this.childNodes[0].getBBox(),\n        h = _b.h,\n        d = _b.d,\n        w = _b.w;\n      var _c = __read(this.TRBL, 4),\n        T = _c[0],\n        R = _c[1],\n        B = _c[2],\n        L = _c[3];\n      return this.getArgMod(L + w + R, T + h + d + B);\n    };\n    class_1.prototype.createMsqrt = function (child) {\n      var mmlFactory = this.node.factory;\n      var mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      var node = this.wrap(mml);\n      node.parent = this;\n      return node;\n    };\n    class_1.prototype.sqrtTRBL = function () {\n      var bbox = this.msqrt.getBBox();\n      var cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    };\n    return class_1;\n  }(Base);\n}\nexports.CommonMencloseMixin = CommonMencloseMixin;","map":{"version":3,"mappings":"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","names":["CommonMencloseMixin","Base","__extends","_i","args","_this","Notation","PADDING","THICKNESS","x","ARROWX","y","ARROWY","dx","ARROWDX","getParameters","getNotations","removeRedundantNotations","initializeNotations","TRBL","getBBoxExtenders","class_1","attributes","node","padding","get","undefined","length2em","thickness","arrowhead","parseFloat","Notations","constructor","notations","name_1","notation","renderChild","renderer","keys","name_2","remove","split","name_3","init","bbox","recompute","T","R","B","L","child","childNodes","getBBox","combine","h","d","w","setChildPWidths","name_4","maximizeEntries","BTRBL","name_5","border","map","i","X","Y","length","direction","Math","abs","atan2","sqrt","_w","_a","_double","_offset","_dist","p","t","r","max","H","getArgMod","a","W","mmlFactory","factory","mml","create","inheritAttributesFrom","wrap","parent","msqrt","cbox","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/output/common/Wrappers/menclose.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport * as Notation from '../Notation.js';\nimport {CommonMsqrt} from './msqrt.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {AbstractMmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {split} from '../../../util/string.js';\n\n/*****************************************************************/\n/**\n * The CommonMenclose interface\n *\n * @template W  The menclose wrapper type\n */\nexport interface CommonMenclose<W extends AnyWrapper, S extends CommonMsqrt, N> extends AnyWrapper {\n  /**\n   *  The notations active on this menclose, and the one to use for the child, if any\n   */\n  notations: Notation.List<W, N>;\n  renderChild: Notation.Renderer<W, N>;\n\n  /**\n   * fake msqrt for radial notation (if used)\n   */\n  msqrt: S;\n\n  /**\n   * The padding, thickness, and shape of the arrow head\n   *   (may be overridden using data-padding, data-thickness, and data-arrowhead attibutes)\n   */\n  padding: number;\n  thickness: number;\n  arrowhead: {x: number, y: number, dx: number};\n\n  /**\n   * The top, right, bottom, and left padding, added by notations\n   */\n  TRBL: Notation.PaddingData;\n\n  /**\n   * Look up the data-* attributes and override the default values\n   */\n  getParameters(): void;\n\n  /**\n   *  Get the notations given in the notation attribute\n   *    and check if any are used to render the child nodes\n   */\n  getNotations(): void;\n\n  /**\n   *  Remove any redundant notations\n   */\n  removeRedundantNotations(): void;\n\n  /**\n   *  Run any initialization needed by notations in use\n   */\n  initializeNotations(): void;\n\n  /**\n   * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n   */\n  getBBoxExtenders(): Notation.PaddingData;\n\n  /**\n   * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n   */\n  getPadding(): Notation.PaddingData;\n\n  /**\n   * Each entry in X gets replaced by the corresponding one in Y if it is larger\n   *\n   * @param {Notation.PaddingData} X   An array of numbers\n   * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n   */\n  maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData): void;\n\n  /**\n   * Get the offset amount for the given direction for vertical and horizontal centering\n   *\n   * @param {string} direction    The direction 'X' or 'Y' for the offset\n   * @return {number}             The amount of offset in that direction\n   */\n  getOffset(direction: string): number;\n\n  /**\n   * @param {number} w    The width of the box whose diagonal is needed\n   * @param {number} h    The height of the box whose diagonal is needed\n   * @return {number[]}   The angle and width of the diagonal of the box\n   */\n  getArgMod(w: number, h: number): [number, number];\n\n  /**\n   * Create an arrow for output\n   *\n   * @param {number} w         The length of the arrow\n   * @param {number} a         The angle for the arrow\n   * @param {boolean} double   True if this is a double-headed arrow\n   * @param {string} offset    'X' for vertical arrow, 'Y' for horizontal\n   * @param {number} trans     Distance to translate in the offset direction\n   * @return {N}               The newly created arrow\n   */\n  arrow(w: number, a: number, double: boolean, offset?: string, trans?: number): N;\n\n  /**\n   * Get the angle and width of a diagonal arrow, plus the x and y extension\n   *   past the content bounding box\n   */\n  arrowData(): {a: number, W: number, x: number, y: number};\n\n  /**\n   * Get the angle and width for a diagonal arrow\n   *\n   * @return {[number, number]}   The angle and width\n   */\n  arrowAW(): [number, number];\n\n  /**\n   * Create an unattached msqrt wrapper to render the 'radical' notation.\n   *   We replace the inferred mrow of the msqrt with the one from the menclose\n   *   but without changing the parent pointer, so as not to detach it from\n   *   the menclose (which would desrtoy the original MathML tree).\n   *\n   * @param {W} child   The inferred mrow that is the child of this menclose\n   * @return {S}        The newly created (but detached) msqrt wrapper\n   */\n  createMsqrt(child: W): S;\n\n  /**\n   * @return {number[]}  The differences between the msqrt bounding box\n   *                     and its child bounding box (i.e., the extra space\n   *                     created by the radical symbol).\n   */\n  sqrtTRBL(): number[];\n}\n\n/**\n * The CommonMenclose class interface\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n */\nexport interface CommonMencloseClass<W extends AnyWrapper, N> extends AnyWrapperClass {\n  /**\n   *  The definitions of the various notations\n   */\n  notations: Notation.DefList<W, N>;\n}\n\n/**\n * Shorthand for the CommonMenclose constructor\n *\n * @template W  The menclose wrapper type\n */\nexport type MencloseConstructor<W extends AnyWrapper, S extends CommonMsqrt, N> = Constructor<CommonMenclose<W, S, N>>;\n\n/*****************************************************************/\n/**\n * The CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n * @templare S  The msqrt wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonMencloseMixin<\n  W extends AnyWrapper,\n  S extends CommonMsqrt,\n  N,\n  T extends WrapperConstructor\n>(Base: T): MencloseConstructor<W, S, N> & T {\n\n  return class extends Base {\n\n    /**\n     *  The notations active on this menclose, if any\n     */\n    public notations: Notation.List<W, N> = {};\n\n    /**\n     *  The notation to use for the child, if any\n     */\n    public renderChild: Notation.Renderer<W, N> = null;\n\n    /**\n     * fake msqrt for radial notation (if used)\n     */\n    public msqrt: S = null;\n\n    /**\n     * The padding of the arrow head (may be overridden using data-padding attibute)\n     */\n    public padding: number = Notation.PADDING;\n    /**\n     * The thickness of the arrow head (may be overridden using data-thickness attibute)\n     */\n    public thickness: number = Notation.THICKNESS;\n    /**\n     * The shape of the arrow head (may be overridden using data-arrowhead attibutes)\n     */\n    public arrowhead = {x: Notation.ARROWX, y: Notation.ARROWY, dx: Notation.ARROWDX};\n\n    /**\n     * The top, right, bottom, and left padding (added by notations)\n     */\n    public TRBL: Notation.PaddingData = [0, 0, 0, 0];\n\n    /**\n     * @override\n     * @constructor\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      this.getParameters();\n      this.getNotations();\n      this.removeRedundantNotations();\n      this.initializeNotations();\n      this.TRBL = this.getBBoxExtenders();\n    }\n\n    /**\n     * Look up the data-* attributes and override the default values\n     */\n    public getParameters() {\n      const attributes = this.node.attributes;\n      const padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      const thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      const arrowhead = attributes.get('data-arrowhead') as string;\n      if (arrowhead !== undefined) {\n        let [x, y, dx] = split(arrowhead);\n        this.arrowhead = {\n          x: (x ? parseFloat(x) : Notation.ARROWX),\n          y: (y ? parseFloat(y) : Notation.ARROWY),\n          dx: (dx ? parseFloat(dx) : Notation.ARROWDX)\n        };\n      }\n    }\n\n    /**\n     *  Get the notations given in the notation attribute\n     *    and check if any are used to render the child nodes\n     */\n    public getNotations() {\n      const Notations = (this.constructor as CommonMencloseClass<W, N>).notations;\n      for (const name of split(this.node.attributes.get('notation') as string)) {\n        const notation = Notations.get(name);\n        if (notation) {\n          this.notations[name] = notation;\n          if (notation.renderChild) {\n            this.renderChild = notation.renderer;\n          }\n        }\n      }\n    }\n\n    /**\n     *  Remove any redundant notations\n     */\n    public removeRedundantNotations() {\n      for (const name of Object.keys(this.notations)) {\n        if (this.notations[name]) {\n          const remove = this.notations[name].remove || '';\n          for (const notation of remove.split(/ /)) {\n            delete this.notations[notation];\n          }\n        }\n      }\n    }\n\n    /**\n     *  Run any initialization needed by notations in use\n     */\n    public initializeNotations() {\n      for (const name of Object.keys(this.notations)) {\n        const init = this.notations[name].init;\n        init && init(this as any);\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      //\n      //  Combine the BBox from the child and add the extenders\n      //\n      let [T, R, B, L] = this.TRBL;\n      const child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n     */\n    public getBBoxExtenders(): Notation.PaddingData {\n      let TRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        this.maximizeEntries(TRBL, this.notations[name].bbox(this as any));\n      }\n      return TRBL;\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n     */\n    public getPadding(): Notation.PaddingData {\n      let BTRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        const border = this.notations[name].border;\n        if (border) {\n          this.maximizeEntries(BTRBL, border(this as any));\n        }\n      }\n      return [0, 1, 2, 3].map(i => this.TRBL[i] - BTRBL[i]) as Notation.PaddingData;\n    }\n\n    /**\n     * Each entry in X gets replaced by the corresponding one in Y if it is larger\n     *\n     * @param {Notation.PaddingData} X   An array of numbers\n     * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n     */\n    public maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData) {\n      for (let i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * Get the offset amount for the given direction for vertical and horizontal centering\n     *\n     * @param {string} direction    The direction 'X' or 'Y' for the offset\n     * @return {number}             The amount of offset in that direction\n     */\n    public getOffset(direction: string): number {\n      let [T, R, B, L] = this.TRBL;\n      const d = (direction === 'X' ? R - L : B - T) / 2;\n      return (Math.abs(d) > .001 ? d : 0);\n    }\n\n    /**\n     * @param {number} w    The width of the box whose diagonal is needed\n     * @param {number} h    The height of the box whose diagonal is needed\n     * @return {number[]}   The angle and width of the diagonal of the box\n     */\n    public getArgMod(w: number, h: number): [number, number] {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    }\n\n    /**\n     * Create an arrow using an svg element\n     *\n     * @param {number} w        The length of the arrow\n     * @param {number} a        The angle for the arrow\n     * @param {boolean} double  True if this is a double-headed arrow\n     * @param {string} offset   'X' for vertical arrow, 'Y' for horizontal\n     * @param {number} dist     Distance to translate in the offset direction\n     * @return {N}              The newly created arrow\n     */\n    public arrow(_w: number, _a: number, _double: boolean, _offset: string = '', _dist: number = 0): N {\n      return null as N;\n    }\n\n    /**\n     * Get the angle and width of a diagonal arrow, plus the x and y extension\n     *   past the content bounding box\n     *\n     * @return {Object}  The angle, width, and x and y extentions\n     */\n    public arrowData(): {a: number, W: number, x: number, y: number} {\n      const [p, t] = [this.padding, this.thickness];\n      const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const H = h + d;\n      const R = Math.sqrt(H * H + w * w);\n      const x = Math.max(p, r * w / R);\n      const y = Math.max(p, r * H / R);\n      const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);\n      return {a, W, x, y};\n    }\n\n    /**\n     * Get the angle and width for a diagonal arrow\n     *\n     * @return {[number, number]}   The angle and width\n     */\n    public arrowAW(): [number, number] {\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const [T, R, B, L] = this.TRBL;\n      return this.getArgMod(L + w + R, T + h + d + B);\n    }\n\n    /********************************************************/\n\n    /**\n     * Create an unattached msqrt wrapper to render the 'radical' notation.\n     *   We replace the inferred mrow of the msqrt with the one from the menclose\n     *   but without changing the parent pointer, so as not to detach it from\n     *   the menclose (which would desrtoy the original MathML tree).\n     *\n     * @param {W} child   The inferred mrow that is the child of this menclose\n     * @return {S}        The newly created (but detached) msqrt wrapper\n     */\n    public createMsqrt(child: W): S {\n      const mmlFactory = (this.node as AbstractMmlNode).factory;\n      const mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      const node = this.wrap(mml) as S;\n      node.parent = this;\n      return node;\n    }\n\n    /**\n     * @return {number[]}  The differences between the msqrt bounding box\n     *                     and its child bounding box (i.e., the extra space\n     *                     created by the radical symbol).\n     */\n    public sqrtTRBL(): [number, number, number, number] {\n      const bbox = this.msqrt.getBBox();\n      const cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    }\n\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}