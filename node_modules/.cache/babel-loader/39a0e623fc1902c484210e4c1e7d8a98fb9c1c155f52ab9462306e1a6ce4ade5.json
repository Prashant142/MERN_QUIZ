{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar NodeUtil_js_1 = __importDefault(require(\"./NodeUtil.js\"));\nvar TexParser_js_1 = __importDefault(require(\"./TexParser.js\"));\nvar TexError_js_1 = __importDefault(require(\"./TexError.js\"));\nvar Entities_js_1 = require(\"../../util/Entities.js\");\nvar ParseUtil;\n(function (ParseUtil) {\n  var emPerInch = 7.2;\n  var pxPerInch = 72;\n  var UNIT_CASES = {\n    'em': function (m) {\n      return m;\n    },\n    'ex': function (m) {\n      return m * .43;\n    },\n    'pt': function (m) {\n      return m / 10;\n    },\n    'pc': function (m) {\n      return m * 1.2;\n    },\n    'px': function (m) {\n      return m * emPerInch / pxPerInch;\n    },\n    'in': function (m) {\n      return m * emPerInch;\n    },\n    'cm': function (m) {\n      return m * emPerInch / 2.54;\n    },\n    'mm': function (m) {\n      return m * emPerInch / 25.4;\n    },\n    'mu': function (m) {\n      return m / 18;\n    }\n  };\n  var num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  var unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  var dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  var dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n  function matchDimen(dim, rest) {\n    if (rest === void 0) {\n      rest = false;\n    }\n    var match = dim.match(rest ? dimenRest : dimenEnd);\n    return match ? muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) : [null, null, 0];\n  }\n  ParseUtil.matchDimen = matchDimen;\n  function muReplace(_a) {\n    var _b = __read(_a, 3),\n      value = _b[0],\n      unit = _b[1],\n      length = _b[2];\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    var em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n  function dimen2em(dim) {\n    var _a = __read(matchDimen(dim), 2),\n      value = _a[0],\n      unit = _a[1];\n    var m = parseFloat(value || '1');\n    var func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n  ParseUtil.dimen2em = dimen2em;\n  function Em(m) {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n  ParseUtil.Em = Em;\n  function cols() {\n    var W = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      W[_i] = arguments[_i];\n    }\n    return W.map(function (n) {\n      return Em(n);\n    }).join(' ');\n  }\n  ParseUtil.cols = cols;\n  function fenced(configuration, open, mml, close, big, color) {\n    if (big === void 0) {\n      big = '';\n    }\n    if (color === void 0) {\n      color = '';\n    }\n    var nf = configuration.nodeFactory;\n    var mrow = nf.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.INNER\n    });\n    var mo;\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.OPEN\n      }, openNode);\n    }\n    NodeUtil_js_1.default.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.CLOSE\n      }, closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil_js_1.default.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n  ParseUtil.fenced = fenced;\n  function fixedFence(configuration, open, mml, close) {\n    var mrow = configuration.nodeFactory.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.ORD\n    });\n    if (open) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil_js_1.default.isType(mml, 'mrow')) {\n      NodeUtil_js_1.default.appendChildren(mrow, NodeUtil_js_1.default.getChildren(mml));\n    } else {\n      NodeUtil_js_1.default.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n  ParseUtil.fixedFence = fixedFence;\n  function mathPalette(configuration, fence, side) {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    var D = '{\\\\bigg' + side + ' ' + fence + '}';\n    var T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser_js_1.default('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n  ParseUtil.mathPalette = mathPalette;\n  function fixInitialMO(configuration, nodes) {\n    for (var i = 0, m = nodes.length; i < m; i++) {\n      var child = nodes[i];\n      if (child && !NodeUtil_js_1.default.isType(child, 'mspace') && (!NodeUtil_js_1.default.isType(child, 'TeXAtom') || NodeUtil_js_1.default.getChildren(child)[0] && NodeUtil_js_1.default.getChildren(NodeUtil_js_1.default.getChildren(child)[0]).length)) {\n        if (NodeUtil_js_1.default.isEmbellished(child) || NodeUtil_js_1.default.isType(child, 'TeXAtom') && NodeUtil_js_1.default.getTexClass(child) === MmlNode_js_1.TEXCLASS.REL) {\n          var mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n  ParseUtil.fixInitialMO = fixInitialMO;\n  function internalMath(parser, text, level, font) {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    var mathvariant = font || parser.stack.env.font;\n    var def = mathvariant ? {\n      mathvariant: mathvariant\n    } : {};\n    var mml = [],\n      i = 0,\n      k = 0,\n      c,\n      node,\n      match = '',\n      braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 1), {}, parser.configuration).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          braces++;\n        } else if (c === '}') {\n          if (match === '}' && braces === 0) {\n            var atom = new TexParser_js_1.default(text.slice(k, i), {}, parser.configuration).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            if (braces) {\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            var len = RegExp['$&'].length;\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              if (k < i - 2) {\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')';\n              k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 2), {}, parser.configuration).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '') {\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i);\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        throw new TexError_js_1.default('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      mml = [parser.create('node', 'mstyle', mml, {\n        displaystyle: false,\n        scriptlevel: level\n      })];\n    } else if (mml.length > 1) {\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n  ParseUtil.internalMath = internalMath;\n  function internalText(parser, text, def) {\n    text = text.replace(/^\\s+/, Entities_js_1.entities.nbsp).replace(/\\s+$/, Entities_js_1.entities.nbsp);\n    var textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n  ParseUtil.internalText = internalText;\n  function underOver(parser, base, script, pos, stack) {\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil_js_1.default.isType(base, 'munderover') && NodeUtil_js_1.default.isEmbellished(base)) {\n      NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(base), {\n        lspace: 0,\n        rspace: 0\n      });\n      var mo = parser.create('node', 'mo', [], {\n        rspace: 0\n      });\n      base = parser.create('node', 'mrow', [mo, base]);\n    }\n    var mml = parser.create('node', 'munderover', [base]);\n    NodeUtil_js_1.default.setChild(mml, pos === 'over' ? mml.over : mml.under, script);\n    var node = mml;\n    if (stack) {\n      node = parser.create('node', 'TeXAtom', [mml], {\n        texClass: MmlNode_js_1.TEXCLASS.OP,\n        movesupsub: true\n      });\n    }\n    NodeUtil_js_1.default.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n  ParseUtil.underOver = underOver;\n  function checkMovableLimits(base) {\n    var symbol = NodeUtil_js_1.default.isType(base, 'mo') ? NodeUtil_js_1.default.getForm(base) : null;\n    if (NodeUtil_js_1.default.getProperty(base, 'movablelimits') || symbol && symbol[3] && symbol[3].movablelimits) {\n      NodeUtil_js_1.default.setProperties(base, {\n        movablelimits: false\n      });\n    }\n  }\n  ParseUtil.checkMovableLimits = checkMovableLimits;\n  function trimSpaces(text) {\n    if (typeof text !== 'string') {\n      return text;\n    }\n    var TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n  ParseUtil.trimSpaces = trimSpaces;\n  function setArrayAlign(array, align) {\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    }\n    return array;\n  }\n  ParseUtil.setArrayAlign = setArrayAlign;\n  function substituteArgs(parser, args, str) {\n    var text = '';\n    var newstring = '';\n    var i = 0;\n    while (i < str.length) {\n      var c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      } else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError_js_1.default('IllegalMacroParam', 'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n  ParseUtil.substituteArgs = substituteArgs;\n  function addArgs(parser, s1, s2) {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError_js_1.default('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' + ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n  ParseUtil.addArgs = addArgs;\n  function checkMaxMacros(parser, isMacro) {\n    if (isMacro === void 0) {\n      isMacro = true;\n    }\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError_js_1.default('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' + 'is here a recursive macro call?');\n    } else {\n      throw new TexError_js_1.default('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' + 'is there a recursive latex environment?');\n    }\n  }\n  ParseUtil.checkMaxMacros = checkMaxMacros;\n  function checkEqnEnv(parser) {\n    if (parser.stack.global.eqnenv) {\n      throw new TexError_js_1.default('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n  ParseUtil.checkEqnEnv = checkEqnEnv;\n  function copyNode(node, parser) {\n    var tree = node.copy();\n    var options = parser.configuration;\n    tree.walkTree(function (n) {\n      var e_1, _a;\n      options.addNode(n.kind, n);\n      var lists = (n.getProperty('in-lists') || '').split(/,/);\n      try {\n        for (var lists_1 = __values(lists), lists_1_1 = lists_1.next(); !lists_1_1.done; lists_1_1 = lists_1.next()) {\n          var list = lists_1_1.value;\n          list && options.addNode(list, n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (lists_1_1 && !lists_1_1.done && (_a = lists_1.return)) _a.call(lists_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n    return tree;\n  }\n  ParseUtil.copyNode = copyNode;\n  function MmlFilterAttribute(_parser, _name, value) {\n    return value;\n  }\n  ParseUtil.MmlFilterAttribute = MmlFilterAttribute;\n  function getFontDef(parser) {\n    var font = parser.stack.env['font'];\n    return font ? {\n      mathvariant: font\n    } : {};\n  }\n  ParseUtil.getFontDef = getFontDef;\n  function keyvalOptions(attrib, allowed, error) {\n    var e_2, _a;\n    if (allowed === void 0) {\n      allowed = null;\n    }\n    if (error === void 0) {\n      error = false;\n    }\n    var def = readKeyval(attrib);\n    if (allowed) {\n      try {\n        for (var _b = __values(Object.keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n          if (!allowed.hasOwnProperty(key)) {\n            if (error) {\n              throw new TexError_js_1.default('InvalidOption', 'Invalid option: %1', key);\n            }\n            delete def[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    return def;\n  }\n  ParseUtil.keyvalOptions = keyvalOptions;\n  function readKeyval(text) {\n    var _a, _b;\n    var options = {};\n    var rest = text;\n    var end, key, val;\n    while (rest) {\n      _a = __read(readValue(rest, ['=', ',']), 3), key = _a[0], end = _a[1], rest = _a[2];\n      if (end === '=') {\n        _b = __read(readValue(rest, [',']), 3), val = _b[0], end = _b[1], rest = _b[2];\n        val = val === 'false' || val === 'true' ? JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n  function removeBraces(text, count) {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n  function readValue(text, end) {\n    var length = text.length;\n    var braces = 0;\n    var value = '';\n    var index = 0;\n    var start = 0;\n    var startCount = true;\n    var stopCount = false;\n    while (index < length) {\n      var c = text[index++];\n      switch (c) {\n        case ' ':\n          break;\n        case '{':\n          if (startCount) {\n            start++;\n          } else {\n            stopCount = false;\n            if (start > braces) {\n              start = braces;\n            }\n          }\n          braces++;\n          break;\n        case '}':\n          if (braces) {\n            braces--;\n          }\n          if (startCount || stopCount) {\n            start--;\n            stopCount = true;\n          }\n          startCount = false;\n          break;\n        default:\n          if (!braces && end.indexOf(c) !== -1) {\n            return [stopCount ? 'true' : removeBraces(value, start), c, text.slice(index)];\n          }\n          startCount = false;\n          stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError_js_1.default('ExtraOpenMissingClose', 'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n})(ParseUtil || (ParseUtil = {}));\nexports.default = ParseUtil;","map":{"version":3,"mappings":"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","names":["ParseUtil","emPerInch","pxPerInch","UNIT_CASES","num","unit","dimenEnd","RegExp","dimenRest","matchDimen","dim","rest","match","muReplace","replace","length","_a","_b","value","em","Em","parseFloat","slice","dimen2em","m","func","Math","abs","toFixed","cols","_i","W","map","n","join","fenced","configuration","open","mml","close","big","color","nf","nodeFactory","mrow","create","texClass","MmlNode_js_1","INNER","mo","TexParser_js_1","parser","stack","env","openNode","fence","stretchy","symmetric","OPEN","NodeUtil_js_1","appendChildren","closeNode","CLOSE","attributes","set","fixedFence","ORD","mathPalette","isType","getChildren","side","D","T","fixInitialMO","nodes","i","child","isEmbellished","getTexClass","REL","mi","unshift","internalMath","text","level","font","options","mathvariant","def","k","c","node","braces","charAt","push","internalText","atom","substr","len","TexError_js_1","displaystyle","scriptlevel","Entities_js_1","nbsp","textNode","underOver","base","script","pos","checkMovableLimits","setProperties","getCoreMO","lspace","rspace","setChild","over","under","OP","movesupsub","setProperty","symbol","getForm","getProperty","movablelimits","trimSpaces","TEXT","trim","setArrayAlign","array","align","arraydef","substituteArgs","args","str","newstring","parseInt","addArgs","s1","s2","checkMaxMacros","isMacro","macroCount","checkEqnEnv","global","eqnenv","copyNode","tree","copy","walkTree","addNode","kind","lists","split","list","MmlFilterAttribute","_parser","_name","getFontDef","keyvalOptions","attrib","allowed","error","readKeyval","keys","key","hasOwnProperty","end","val","readValue","JSON","parse","removeBraces","count","index","start","startCount","stopCount","indexOf","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/input/tex/ParseUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview A namespace for utility functions for the TeX Parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TEXCLASS, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {EnvList} from './StackItem.js';\nimport {ArrayItem} from './base/BaseItems.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\nimport TexParser from './TexParser.js';\nimport TexError from './TexError.js';\nimport {entities} from '../../util/Entities.js';\nimport {MmlMunderover} from '../../core/MmlTree/MmlNodes/munderover.js';\n\n\nnamespace ParseUtil {\n\n  // TODO (VS): Combine some of this with lengths in util.\n  const emPerInch = 7.2;\n  const pxPerInch = 72;\n  // Note, the following are TeX CM font values.\n  const UNIT_CASES: {[key: string]: ((m: number) => number)}  = {\n    'em': m => m,\n    'ex': m => m * .43,\n    'pt': m => m / 10,                    // 10 pt to an em\n    'pc': m => m * 1.2,                   // 12 pt to a pc\n    'px': m => m * emPerInch / pxPerInch,\n    'in': m => m * emPerInch,\n    'cm': m => m * emPerInch / 2.54, // 2.54 cm to an inch\n    'mm': m => m * emPerInch / 25.4, // 10 mm to a cm\n    'mu': m => m / 18,\n  };\n  const num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  const unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  const dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  const dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n\n  /**\n   * Matches for a dimension argument.\n   * @param {string} dim The argument.\n   * @param {boolean} rest Allow for trailing garbage in the dimension string.\n   * @return {[string, string, number]} The match result as (Anglosaxon) value,\n   *     unit name, length of matched string. The latter is interesting in the\n   *     case of trailing garbage.\n   */\n  export function matchDimen(\n    dim: string, rest: boolean = false): [string, string, number] {\n      let match = dim.match(rest ? dimenRest : dimenEnd);\n      return match ?\n        muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :\n        [null, null, 0];\n  }\n\n\n  /**\n   * Transforms mu dimension to em if necessary.\n   * @param {[string, string, number]} [value, unit, length] The dimension triple.\n   * @return {[string, string, number]} [value, unit, length] The transformed triple.\n   */\n  function muReplace([value, unit, length]: [string, string, number]): [string, string, number] {\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    let em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n\n  /**\n   * Convert a dimension string into standard em dimension.\n   * @param {string} dim The attribute string.\n   * @return {number} The numerical value.\n   */\n  export function dimen2em(dim: string): number {\n    let [value, unit] = matchDimen(dim);\n    let m = parseFloat(value || '1');\n    let func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n\n  /**\n   * Turns a number into an em value.\n   * @param {number} m The number.\n   * @return {string} The em dimension string.\n   */\n  export function Em(m: number): string {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n\n  /**\n   * Takes an array of numbers and returns a space-separated string of em values.\n   * @param {number[]} W  The widths to be turned into em values\n   * @return {string}     The numbers with em units, separated by spaces.\n   */\n  export function cols(...W: number[]): string {\n    return W.map(n => Em(n)).join(' ');\n  }\n\n\n  /**\n   * Create an mrow that has stretchy delimiters at either end, as needed\n   * @param {ParseOptions} configuration Current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @param {string=} big Bigg command.\n   */\n  export function fenced(configuration: ParseOptions, open: string, mml: MmlNode,\n                         close: string, big: string = '', color: string = '') {\n    // @test Fenced, Fenced3\n    let nf = configuration.nodeFactory;\n    let mrow = nf.create('node', 'mrow', [],\n                         {open: open, close: close, texClass: TEXCLASS.INNER});\n    let mo;\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.OPEN},\n                     openNode);\n    }\n    NodeUtil.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.CLOSE},\n                     closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n\n  /**\n   *  Create an mrow that has \\\\mathchoice using \\\\bigg and \\\\big for the delimiters.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @return {MmlNode} The mrow node.\n   */\n  export function fixedFence(configuration: ParseOptions, open: string,\n                             mml: MmlNode, close: string): MmlNode {\n    // @test Choose, Over With Delims, Above with Delims\n    let mrow = configuration.nodeFactory.create('node',\n      'mrow', [], {open: open, close: close, texClass: TEXCLASS.ORD});\n    if (open) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil.isType(mml, 'mrow')) {\n      NodeUtil.appendChildren(mrow, NodeUtil.getChildren(mml));\n    } else {\n      NodeUtil.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n\n\n  /**\n   * Generates a mathchoice element for fences. These will be resolved later,\n   * once the position, and therefore size, of the of the fenced expression is\n   * known.\n   * @param {ParseOptions} configuration The current parse otpions.\n   * @param {string} fence The fence.\n   * @param {string} side The side of the fence (l or r).\n   * @return {MmlNode} The mathchoice node.\n   */\n  export function mathPalette(configuration: ParseOptions, fence: string,\n                              side: string): MmlNode  {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    let D = '{\\\\bigg' + side + ' ' + fence + '}';\n    let T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n\n  /**\n   * If the initial child, skipping any initial space or\n   * empty braces (TeXAtom with child being an empty inferred row),\n   * is an <mo>, precede it by an empty <mi> to force the <mo> to\n   * be infix.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {MmlNode[]} nodes The row of nodes to scan for an initial <mo>\n   */\n  export function fixInitialMO(configuration: ParseOptions, nodes: MmlNode[]) {\n    for (let i = 0, m = nodes.length; i < m; i++) {\n      let child = nodes[i];\n      if (child && (!NodeUtil.isType(child, 'mspace') &&\n                    (!NodeUtil.isType(child, 'TeXAtom') ||\n                     (NodeUtil.getChildren(child)[0] &&\n                      NodeUtil.getChildren(NodeUtil.getChildren(child)[0]).length)))) {\n        if (NodeUtil.isEmbellished(child) ||\n            (NodeUtil.isType(child, 'TeXAtom') && NodeUtil.getTexClass(child) === TEXCLASS.REL)) {\n          let mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Break up a string into text and math blocks.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} text The text in the math expression to parse.\n   * @param {number|string=} level The scriptlevel.\n   * @param {string} font The mathvariant to use\n   * @return {MmlNode[]} The nodes corresponding to the internal math expression.\n   */\n  export function internalMath(parser: TexParser, text: string,\n                               level?: number | string, font?: string): MmlNode[] {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    let mathvariant = font || parser.stack.env.font;\n    let def = (mathvariant ? {mathvariant} : {});\n    let mml: MmlNode[] = [], i = 0, k = 0, c, node, match = '', braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            // @test Interspersed Text\n            node = parser.create(\n              'node', 'TeXAtom',\n              [(new TexParser(text.slice(k, i - 1), {}, parser.configuration)).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            // @test Interspersed Text\n            if (k < i - 1) {\n              // @test Interspersed Text\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          // @test Mbox Mbox, Mbox Math\n          braces++;\n        } else if (c === '}') {\n          // @test Mbox Mbox, Mbox Math\n          if (match === '}' && braces === 0) {\n            // @test Mbox Eqref, Mbox Math\n            let atom = (new TexParser(text.slice(k, i), {}, parser.configuration)).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            // @test Mbox Math, Mbox Mbox\n            if (braces) {\n              // @test Mbox Math, Mbox Mbox\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          // @test Mbox Eqref, Mbox CR\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            // @test Mbox Eqref\n            let len = ((RegExp as any)['$&'] as string).length;\n            if (k < i - 1) {\n              // @test Mbox Eqref\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            // @test Mbox CR, Mbox Mbox\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              // @test Mbox Internal Display\n              if (k < i - 2) {\n                // @test Mbox Internal Display\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')'; k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              // @test Mbox Internal Display\n              node = parser.create(\n                'node', 'TeXAtom',\n                [(new TexParser(text.slice(k, i - 2), {}, parser.configuration)).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '')  {\n              // @test Mbox CR\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i); // remove \\ from \\$, \\{, \\}, or \\\\\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        // @test Internal Math Error\n        throw new TexError('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      // @test Interspersed Text, Mbox Mbox\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      // @test Label, Fbox, Hbox\n      mml = [parser.create('node', 'mstyle', mml, {displaystyle: false, scriptlevel: level})];\n    } else if (mml.length > 1) {\n      // @test Interspersed Text\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n\n\n  /**\n   * Parses text internal to boxes or labels.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} text The text to parse.\n   * @param {EnvList} def The attributes of the text node.\n   * @return {MmlNode} The text node.\n   */\n  export function internalText(parser: TexParser, text: string, def: EnvList): MmlNode {\n    // @test Label, Fbox, Hbox\n    text = text.replace(/^\\s+/, entities.nbsp).replace(/\\s+$/, entities.nbsp);\n    let textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  /**\n   * Create an munderover node with the given script position.\n   * @param {TexParser} parser   The current TeX parser.\n   * @param {MmlNode} base       The base node.\n   * @param {MmlNode} script     The under- or over-script.\n   * @param {string} pos         Either 'over' or 'under'.\n   * @param {boolean} stack      True if super- or sub-scripts should stack.\n   * @return {MmlNode}           The generated node (MmlMunderover or TeXAtom)\n   */\n  export function underOver(parser: TexParser, base: MmlNode, script: MmlNode, pos: string, stack: boolean): MmlNode {\n    // @test Overline\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil.isType(base, 'munderover') && NodeUtil.isEmbellished(base)) {\n      // @test Overline Limits\n      NodeUtil.setProperties(NodeUtil.getCoreMO(base), {lspace: 0, rspace: 0});\n      const mo = parser.create('node', 'mo', [], {rspace: 0});\n      base = parser.create('node', 'mrow', [mo, base]);\n      // TODO? add an empty <mi> so it's not embellished any more\n    }\n    const mml = parser.create('node', 'munderover', [base]) as MmlMunderover;\n    NodeUtil.setChild(mml, pos === 'over' ?  mml.over : mml.under, script);\n    let node: MmlNode = mml;\n    if (stack) {\n      // @test Overbrace 1 2 3, Underbrace, Overbrace Op 1 2\n      node = parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP, movesupsub: true});\n    }\n    NodeUtil.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  /**\n   * Set movablelimits to false if necessary.\n   * @param {MmlNode} base   The base node being tested.\n   */\n  export function checkMovableLimits(base: MmlNode) {\n    const symbol = (NodeUtil.isType(base, 'mo') ? NodeUtil.getForm(base) : null);\n    if (NodeUtil.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {\n      // @test Overline Sum\n      NodeUtil.setProperties(base, {movablelimits: false});\n    }\n  }\n\n  /**\n   * Trim spaces from a string.\n   * @param {string} text The string to clean.\n   * @return {string} The string with leading and trailing whitespace removed.\n   */\n  export function trimSpaces(text: string): string {\n    if (typeof(text) !== 'string') {\n      return text;\n    }\n    let TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n\n\n  /**\n   * Sets alignment in array definitions.\n   * @param {ArrayItem} array The array item.\n   * @param {string} align The alignment string.\n   * @return {ArrayItem} The altered array item.\n   */\n  export function setArrayAlign(array: ArrayItem, align: string): ArrayItem {\n    // @test Array1, Array2, Array Test\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    } // FIXME: should be an error?\n    return array;\n  }\n\n\n  /**\n   * Replace macro parameters with their values.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string[]} args A list of arguments for macro parameters.\n   * @param {string} str The macro parameter string.\n   * @return {string} The string with all parameters replaced by arguments.\n   */\n  export function substituteArgs(parser: TexParser, args: string[],\n                                 str: string): string {\n    let text = '';\n    let newstring = '';\n    let i = 0;\n    while (i < str.length) {\n      let c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      }\n      else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError('IllegalMacroParam',\n                                'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text),\n                              args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n\n\n  /**\n   * Adds a new expanded argument to an already macro parameter string.  Makes\n   * sure that macros are followed by a space if their names could accidentally\n   * be continued into the following text.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string} s1 The already expanded string.\n   * @param {string} s2 The string to add.\n   * @return {string} The combined string.\n   */\n  export function addArgs(parser: TexParser, s1: string, s2: string): string {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError('MaxBufferSize',\n                          'MathJax internal buffer size exceeded; is there a' +\n                          ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n\n  /**\n   * Report an error if there are too many macro substitutions.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {boolean} isMacro  True if we are substituting a macro, false for environment.\n   */\n  export function checkMaxMacros(parser: TexParser, isMacro: boolean = true) {\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError('MaxMacroSub1',\n                         'MathJax maximum macro substitution count exceeded; ' +\n                         'is here a recursive macro call?');\n    } else {\n      throw new TexError('MaxMacroSub2',\n                         'MathJax maximum substitution count exceeded; ' +\n                         'is there a recursive latex environment?');\n    }\n  }\n\n\n  /**\n   *  Check for bad nesting of equation environments\n   */\n  export function checkEqnEnv(parser: TexParser) {\n    if (parser.stack.global.eqnenv) {\n      // @test ErroneousNestingEq\n      throw new TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n\n  /**\n   * Copy an MmlNode and add it (and its children) to the proper lists.\n   *\n   * @param {MmlNode} node       The MmlNode to copy\n   * @param {TexParser} parser   The active tex parser\n   * @return {MmlNode}           The duplicate tree\n   */\n  export function copyNode(node: MmlNode, parser: TexParser): MmlNode  {\n    const tree = node.copy() as MmlNode;\n    const options = parser.configuration;\n    tree.walkTree((n: MmlNode) => {\n      options.addNode(n.kind, n);\n      const lists = (n.getProperty('in-lists') as string || '').split(/,/);\n      for (const list of lists) {\n        list && options.addNode(list, n);\n      }\n    });\n    return tree;\n  }\n\n  /**\n   * This is a placeholder for future security filtering of attributes.\n   * @param {TexParser} parser The current parser.\n   * @param {string} name The attribute name.\n   * @param {string} value The attribute value to filter.\n   * @return {string} The filtered value.\n   */\n  export function MmlFilterAttribute(_parser: TexParser, _name: string, value: string): string {\n    // TODO: Implement in security package.\n    return value;\n  }\n\n\n  /**\n   * Initialises an stack environment with current font definition in the parser.\n   * @param {TexParser} parser The current tex parser.\n   * @return {EnvList} The initialised environment list.\n   */\n  export function getFontDef(parser: TexParser): EnvList {\n    const font = parser.stack.env['font'];\n    return (font ? {mathvariant: font} : {});\n  }\n\n\n  /**\n   * Splits a package option list of the form [x=y,z=1] into an attribute list\n   * of the form {x: y, z: 1}.\n   * @param {string} attrib The attributes of the package.\n   * @param {{[key: string]: number}?} allowed A list of allowed options. If\n   *     given only allowed arguments are returned.\n   * @param {boolean?} error If true, raises an exception if not allowed options\n   *     are found.\n   * @return {EnvList} The attribute list.\n   */\n  export function keyvalOptions(attrib: string,\n                                allowed: {[key: string]: number} = null,\n                                error: boolean = false): EnvList {\n    let def: EnvList = readKeyval(attrib);\n    if (allowed) {\n      for (let key of Object.keys(def)) {\n        if (!allowed.hasOwnProperty(key)) {\n          if (error) {\n            throw new TexError('InvalidOption', 'Invalid option: %1', key);\n          }\n          delete def[key];\n        }\n      }\n    }\n    return def;\n  }\n\n\n  /**\n   * Implementation of the keyval function from https://www.ctan.org/pkg/keyval\n   * @param {string} text The optional parameter string for a package or\n   *     command.\n   * @return {EnvList} Set of options as key/value pairs.\n   */\n  function readKeyval(text: string): EnvList {\n    let options: EnvList = {};\n    let rest = text;\n    let end, key, val;\n    while (rest) {\n      [key, end, rest] = readValue(rest, ['=', ',']);\n      if (end === '=') {\n        [val, end, rest] = readValue(rest, [',']);\n        val = (val === 'false' || val === 'true') ?\n            JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n\n\n  /**\n   * Removes pairs of outer braces.\n   * @param {string} text The string to clean.\n   * @param {number} count The number of outer braces to slice off.\n   * @return {string} The cleaned string.\n   */\n  function removeBraces(text: string, count: number): string {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n\n\n  /**\n   * Read a value from the given string until an end parameter is reached or\n   * string is exhausted.\n   * @param {string} text The string to process.\n   * @param {string[]} end List of possible end characters.\n   * @return {[string, string, string]} The collected value, the actual end\n   *     character, and the rest of the string still to parse.\n   */\n  function readValue(text: string, end: string[]): [string, string, string] {\n    let length = text.length;\n    let braces = 0;\n    let value = '';\n    let index = 0;\n    let start = 0;             // Counter for the starting left braces.\n    let startCount = true;     // Flag for counting starting left braces.\n    let stopCount = false;     // If true right braces are found directly\n                               // after starting braces, but no other char yet.\n    while (index < length) {\n      let c = text[index++];\n      switch (c) {\n      case ' ':                // Ignore spaces.\n        break;\n      case '{':\n        if (startCount) {      // Count start left braces at start.\n          start++;\n        } else {\n          stopCount = false;\n          if (start > braces) {   // Some start left braces have been closed.\n            start = braces;\n          }\n        }\n        braces++;\n        break;\n      case '}':\n        if (braces) {          // Closing braces.\n          braces--;\n        }\n        if (startCount || stopCount) {  // Closing braces at the start.\n          start--;\n          stopCount = true;    // Continue to close braces.\n        }\n        startCount = false;    // Stop counting start left braces.\n        break;\n      default:\n        if (!braces && end.indexOf(c) !== -1) {   // End character reached.\n          return [stopCount ? 'true' :            // If Stop count is true we\n                                                  // have balanced braces, only.\n                  removeBraces(value, start), c, text.slice(index)];\n        }\n        startCount = false;\n        stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError('ExtraOpenMissingClose',\n                         'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n\n}\n\nexport default ParseUtil;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}