{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonMoMixin = exports.DirectionVH = void 0;\nvar BBox_js_1 = require(\"../../../util/BBox.js\");\nvar string_js_1 = require(\"../../../util/string.js\");\nvar FontData_js_1 = require(\"../FontData.js\");\nexports.DirectionVH = (_a = {}, _a[1] = 'v', _a[2] = 'h', _a);\nfunction CommonMoMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n      _this.size = null;\n      _this.isAccent = _this.node.isAccent;\n      return _this;\n    }\n    class_1.prototype.computeBBox = function (bbox, _recompute) {\n      if (_recompute === void 0) {\n        _recompute = false;\n      }\n      this.protoBBox(bbox);\n      if (this.node.attributes.get('symmetric') && this.stretch.dir !== 2) {\n        var d = this.getCenterOffset(bbox);\n        bbox.h += d;\n        bbox.d -= d;\n      }\n      if (this.node.getProperty('mathaccent') && (this.stretch.dir === 0 || this.size >= 0)) {\n        bbox.w = 0;\n      }\n    };\n    class_1.prototype.protoBBox = function (bbox) {\n      var stretchy = this.stretch.dir !== 0;\n      if (stretchy && this.size === null) {\n        this.getStretchedVariant([0]);\n      }\n      if (stretchy && this.size < 0) return;\n      _super.prototype.computeBBox.call(this, bbox);\n      this.copySkewIC(bbox);\n    };\n    class_1.prototype.getAccentOffset = function () {\n      var bbox = BBox_js_1.BBox.empty();\n      this.protoBBox(bbox);\n      return -bbox.w / 2;\n    };\n    class_1.prototype.getCenterOffset = function (bbox) {\n      if (bbox === void 0) {\n        bbox = null;\n      }\n      if (!bbox) {\n        bbox = BBox_js_1.BBox.empty();\n        _super.prototype.computeBBox.call(this, bbox);\n      }\n      return (bbox.h + bbox.d) / 2 + this.font.params.axis_height - bbox.h;\n    };\n    class_1.prototype.getVariant = function () {\n      if (this.node.attributes.get('largeop')) {\n        this.variant = this.node.attributes.get('displaystyle') ? '-largeop' : '-smallop';\n        return;\n      }\n      if (!this.node.attributes.getExplicit('mathvariant') && this.node.getProperty('pseudoscript') === false) {\n        this.variant = '-tex-variant';\n        return;\n      }\n      _super.prototype.getVariant.call(this);\n    };\n    class_1.prototype.canStretch = function (direction) {\n      if (this.stretch.dir !== 0) {\n        return this.stretch.dir === direction;\n      }\n      var attributes = this.node.attributes;\n      if (!attributes.get('stretchy')) return false;\n      var c = this.getText();\n      if (Array.from(c).length !== 1) return false;\n      var delim = this.font.getDelimiter(c.codePointAt(0));\n      this.stretch = delim && delim.dir === direction ? delim : FontData_js_1.NOSTRETCH;\n      return this.stretch.dir !== 0;\n    };\n    class_1.prototype.getStretchedVariant = function (WH, exact) {\n      var e_1, _a;\n      if (exact === void 0) {\n        exact = false;\n      }\n      if (this.stretch.dir !== 0) {\n        var D = this.getWH(WH);\n        var min = this.getSize('minsize', 0);\n        var max = this.getSize('maxsize', Infinity);\n        var mathaccent = this.node.getProperty('mathaccent');\n        D = Math.max(min, Math.min(max, D));\n        var df = this.font.params.delimiterfactor / 1000;\n        var ds = this.font.params.delimitershortfall;\n        var m = min || exact ? D : mathaccent ? Math.min(D / df, D + ds) : Math.max(D * df, D - ds);\n        var delim = this.stretch;\n        var c = delim.c || this.getText().codePointAt(0);\n        var i = 0;\n        if (delim.sizes) {\n          try {\n            for (var _b = __values(delim.sizes), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var d = _c.value;\n              if (d >= m) {\n                if (mathaccent && i) {\n                  i--;\n                }\n                this.variant = this.font.getSizeVariant(c, i);\n                this.size = i;\n                if (delim.schar && delim.schar[i]) {\n                  this.stretch = __assign(__assign({}, this.stretch), {\n                    c: delim.schar[i]\n                  });\n                }\n                return;\n              }\n              i++;\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n        if (delim.stretch) {\n          this.size = -1;\n          this.invalidateBBox();\n          this.getStretchBBox(WH, this.checkExtendedHeight(D, delim), delim);\n        } else {\n          this.variant = this.font.getSizeVariant(c, i - 1);\n          this.size = i - 1;\n        }\n      }\n    };\n    class_1.prototype.getSize = function (name, value) {\n      var attributes = this.node.attributes;\n      if (attributes.isSet(name)) {\n        value = this.length2em(attributes.get(name), 1, 1);\n      }\n      return value;\n    };\n    class_1.prototype.getWH = function (WH) {\n      if (WH.length === 0) return 0;\n      if (WH.length === 1) return WH[0];\n      var _a = __read(WH, 2),\n        H = _a[0],\n        D = _a[1];\n      var a = this.font.params.axis_height;\n      return this.node.attributes.get('symmetric') ? 2 * Math.max(H - a, D + a) : H + D;\n    };\n    class_1.prototype.getStretchBBox = function (WHD, D, C) {\n      var _a;\n      if (C.hasOwnProperty('min') && C.min > D) {\n        D = C.min;\n      }\n      var _b = __read(C.HDW, 3),\n        h = _b[0],\n        d = _b[1],\n        w = _b[2];\n      if (this.stretch.dir === 1) {\n        _a = __read(this.getBaseline(WHD, D, C), 2), h = _a[0], d = _a[1];\n      } else {\n        w = D;\n      }\n      this.bbox.h = h;\n      this.bbox.d = d;\n      this.bbox.w = w;\n    };\n    class_1.prototype.getBaseline = function (WHD, HD, C) {\n      var hasWHD = WHD.length === 2 && WHD[0] + WHD[1] === HD;\n      var symmetric = this.node.attributes.get('symmetric');\n      var _a = __read(hasWHD ? WHD : [HD, 0], 2),\n        H = _a[0],\n        D = _a[1];\n      var _b = __read([H + D, 0], 2),\n        h = _b[0],\n        d = _b[1];\n      if (symmetric) {\n        var a = this.font.params.axis_height;\n        if (hasWHD) {\n          h = 2 * Math.max(H - a, D + a);\n        }\n        d = h / 2 - a;\n      } else if (hasWHD) {\n        d = D;\n      } else {\n        var _c = __read(C.HDW || [.75, .25], 2),\n          ch = _c[0],\n          cd = _c[1];\n        d = cd * (h / (ch + cd));\n      }\n      return [h - d, d];\n    };\n    class_1.prototype.checkExtendedHeight = function (D, C) {\n      if (C.fullExt) {\n        var _a = __read(C.fullExt, 2),\n          extSize = _a[0],\n          endSize = _a[1];\n        var n = Math.ceil(Math.max(0, D - endSize) / extSize);\n        D = endSize + n * extSize;\n      }\n      return D;\n    };\n    class_1.prototype.remapChars = function (chars) {\n      var primes = this.node.getProperty('primes');\n      if (primes) {\n        return (0, string_js_1.unicodeChars)(primes);\n      }\n      if (chars.length === 1) {\n        var parent_1 = this.node.coreParent().parent;\n        var isAccent = this.isAccent && !parent_1.isKind('mrow');\n        var map = isAccent ? 'accent' : 'mo';\n        var text = this.font.getRemappedChar(map, chars[0]);\n        if (text) {\n          chars = this.unicodeChars(text, this.variant);\n        }\n      }\n      return chars;\n    };\n    return class_1;\n  }(Base);\n}\nexports.CommonMoMixin = CommonMoMixin;","map":{"version":3,"mappings":"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","names":["exports","_a","CommonMoMixin","Base","__extends","_i","args","_this","isAccent","node","class_1","bbox","_recompute","protoBBox","attributes","get","stretch","dir","d","getCenterOffset","h","getProperty","size","w","stretchy","getStretchedVariant","_super","computeBBox","copySkewIC","BBox_js_1","empty","font","params","axis_height","variant","getExplicit","getVariant","direction","c","getText","Array","from","length","delim","getDelimiter","codePointAt","FontData_js_1","WH","exact","D","getWH","min","getSize","max","Infinity","mathaccent","Math","df","delimiterfactor","ds","delimitershortfall","m","i","sizes","getSizeVariant","schar","invalidateBBox","getStretchBBox","checkExtendedHeight","name","value","isSet","length2em","H","a","WHD","C","hasOwnProperty","HDW","getBaseline","HD","hasWHD","symmetric","ch","cd","fullExt","extSize","endSize","n","ceil","chars","primes","parent_1","coreParent","parent","isKind","map","text","getRemappedChar","unicodeChars"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/output/common/Wrappers/mo.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonMo wrapper mixin for the MmlMo object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor} from '../Wrapper.js';\nimport {MmlMo} from '../../../core/MmlTree/MmlNodes/mo.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {unicodeChars} from '../../../util/string.js';\nimport {DelimiterData} from '../FontData.js';\nimport {DIRECTION, NOSTRETCH} from '../FontData.js';\n\n/*****************************************************************/\n/**\n * Convert direction to letter\n */\nexport const DirectionVH: {[n: number]: string} = {\n  [DIRECTION.Vertical]: 'v',\n  [DIRECTION.Horizontal]: 'h'\n};\n\n/*****************************************************************/\n/**\n * The CommonMo interface\n */\nexport interface CommonMo extends AnyWrapper {\n\n  /**\n   * The font size that a stretched operator uses.\n   * If -1, then stretch arbitrarily, and bbox gives the actual height, depth, width\n   */\n  size: number;\n\n  /**\n   * True if used as an accent in an munderover construct\n   */\n  isAccent: boolean;\n\n  /**\n   * Get the (unmodified) bbox of the contents (before centering or setting accents to width 0)\n   *\n   * @param {BBox} bbox   The bbox to fill\n   */\n  protoBBox(bbox: BBox): void;\n\n  /**\n   * @return {number}    Offset to the left by half the actual width of the accent\n   */\n  getAccentOffset(): number;\n\n  /**\n   * @param {BBox} bbox   The bbox to center, or null to compute the bbox\n   * @return {number}     The offset to move the glyph to center it\n   */\n  getCenterOffset(bbox?: BBox): number;\n\n  /**\n   * Determint variant for vertically/horizontally stretched character\n   *\n   * @param {number[]} WH  size to stretch to, either [W] or [H, D]\n   * @param {boolean} exact  True if not allowed to use delimiter factor and shortfall\n   */\n  getStretchedVariant(WH: number[], exact?: boolean): void;\n\n  /**\n   * @param {string} name   The name of the attribute to get\n   * @param {number} value  The default value to use\n   * @return {number}       The size in em's of the attribute (or the default value)\n   */\n  getSize(name: string, value: number): number;\n\n  /**\n   * @param {number[]} WH  Either [W] for width, [H, D] for height and depth, or [] for min/max size\n   * @return {number}      Either the width or the total height of the character\n   */\n  getWH(WH: number[]): number;\n\n  /**\n   * @param {number[]} WHD     The [W] or [H, D] being requested from the parent mrow\n   * @param {number} D         The full dimension (including symmetry, etc)\n   * @param {DelimiterData} C  The delimiter data for the stretchy character\n   */\n  getStretchBBox(WHD: number[], D: number, C: DelimiterData): void;\n\n  /**\n   * @param {number[]} WHD     The [H, D] being requested from the parent mrow\n   * @param {number} HD        The full height (including symmetry, etc)\n   * @param {DelimiterData} C  The delimiter data for the stretchy character\n   * @return {number[]}        The height and depth for the vertically stretched delimiter\n   */\n  getBaseline(WHD: number[], HD: number, C: DelimiterData): number[];\n\n  /**\n   * Determine the size of the delimiter based on whether full extenders should be used or not.\n   *\n   * @param {number} D          The requested size of the delimiter\n   * @param {DelimiterData} C   The data for the delimiter\n   * @return {number}           The final size of the assembly\n   */\n  checkExtendedHeight(D: number, C: DelimiterData): number;\n\n}\n\n/**\n * Shorthand for the CommonMo constructor\n */\nexport type MoConstructor = Constructor<CommonMo>;\n\n/*****************************************************************/\n/**\n * The CommomMo wrapper mixin for the MmlMo object\n *\n * @template T  The Wrapper class constructor type\n */\nexport function CommonMoMixin<T extends WrapperConstructor>(Base: T): MoConstructor & T {\n\n  return class extends Base {\n\n    /**\n     * The font size that a stretched operator uses.\n     * If -1, then stretch arbitrarily, and bbox gives the actual height, depth, width\n     */\n    public size: number = null;\n\n    /**\n     * True if used as an accent in an munderover construct\n     */\n    public isAccent: boolean;\n\n    /**\n     * @override\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      this.isAccent = (this.node as MmlMo).isAccent;\n    }\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, _recompute: boolean = false) {\n      this.protoBBox(bbox);\n      if (this.node.attributes.get('symmetric') &&\n          this.stretch.dir !== DIRECTION.Horizontal) {\n        const d = this.getCenterOffset(bbox);\n        bbox.h += d;\n        bbox.d -= d;\n      }\n      if (this.node.getProperty('mathaccent') &&\n          (this.stretch.dir === DIRECTION.None || this.size >= 0)) {\n        bbox.w = 0;\n      }\n    }\n\n    /**\n     * Get the (unmodified) bbox of the contents (before centering or setting accents to width 0)\n     *\n     * @param {BBox} bbox   The bbox to fill\n     */\n    public protoBBox(bbox: BBox) {\n      const stretchy = (this.stretch.dir !== DIRECTION.None);\n      if (stretchy && this.size === null) {\n        this.getStretchedVariant([0]);\n      }\n      if (stretchy && this.size < 0) return;\n      super.computeBBox(bbox);\n      this.copySkewIC(bbox);\n    }\n\n    /**\n     * @return {number}    Offset to the left by half the actual width of the accent\n     */\n    public getAccentOffset(): number {\n      const bbox = BBox.empty();\n      this.protoBBox(bbox);\n      return -bbox.w / 2;\n    }\n\n    /**\n     * @param {BBox} bbox   The bbox to center, or null to compute the bbox\n     * @return {number}     The offset to move the glyph to center it\n     */\n    public getCenterOffset(bbox: BBox = null): number {\n      if (!bbox) {\n        bbox = BBox.empty();\n        super.computeBBox(bbox);\n      }\n      return ((bbox.h + bbox.d) / 2 + this.font.params.axis_height) - bbox.h;\n    }\n\n    /**\n     * @override\n     */\n    public getVariant() {\n      if (this.node.attributes.get('largeop')) {\n        this.variant = (this.node.attributes.get('displaystyle') ? '-largeop' : '-smallop');\n        return;\n      }\n      if (!this.node.attributes.getExplicit('mathvariant') &&\n          this.node.getProperty('pseudoscript') === false) {\n        this.variant = '-tex-variant';\n        return;\n      }\n      super.getVariant();\n    }\n\n    /**\n     * @override\n     */\n    public canStretch(direction: DIRECTION) {\n      if (this.stretch.dir !== DIRECTION.None) {\n        return this.stretch.dir === direction;\n      }\n      const attributes = this.node.attributes;\n      if (!attributes.get('stretchy')) return false;\n      const c = this.getText();\n      if (Array.from(c).length !== 1) return false;\n      const delim = this.font.getDelimiter(c.codePointAt(0));\n      this.stretch = (delim && delim.dir === direction ? delim : NOSTRETCH);\n      return this.stretch.dir !== DIRECTION.None;\n    }\n\n    /**\n     * Determint variant for vertically/horizontally stretched character\n     *\n     * @param {number[]} WH  size to stretch to, either [W] or [H, D]\n     * @param {boolean} exact  True if not allowed to use delimiter factor and shortfall\n     */\n    public getStretchedVariant(WH: number[], exact: boolean = false) {\n      if (this.stretch.dir !== DIRECTION.None) {\n        let D = this.getWH(WH);\n        const min = this.getSize('minsize', 0);\n        const max = this.getSize('maxsize', Infinity);\n        const mathaccent = this.node.getProperty('mathaccent');\n        //\n        //  Clamp the dimension to the max and min\n        //  then get the target size via TeX rules\n        //\n        D = Math.max(min, Math.min(max, D));\n        const df = this.font.params.delimiterfactor / 1000;\n        const ds = this.font.params.delimitershortfall;\n        const m = (min || exact ? D : mathaccent ? Math.min(D / df, D + ds) :  Math.max(D * df, D - ds));\n        //\n        //  Look through the delimiter sizes for one that matches\n        //\n        const delim = this.stretch;\n        const c = delim.c || this.getText().codePointAt(0);\n        let i = 0;\n        if (delim.sizes) {\n          for (const d of delim.sizes) {\n            if (d >= m) {\n              if (mathaccent && i) {\n                i--;\n              }\n              this.variant = this.font.getSizeVariant(c, i);\n              this.size = i;\n              if (delim.schar && delim.schar[i]) {\n                this.stretch = {...this.stretch, c: delim.schar[i]};\n              }\n              return;\n            }\n            i++;\n          }\n        }\n        //\n        //  No size matches, so if we can make multi-character delimiters,\n        //  record the data for that, otherwise, use the largest fixed size.\n        //\n        if (delim.stretch) {\n          this.size = -1;\n          this.invalidateBBox();\n          this.getStretchBBox(WH, this.checkExtendedHeight(D, delim), delim);\n        } else {\n          this.variant = this.font.getSizeVariant(c, i - 1);\n          this.size = i - 1;\n        }\n      }\n    }\n\n    /**\n     * @param {string} name   The name of the attribute to get\n     * @param {number} value  The default value to use\n     * @return {number}       The size in em's of the attribute (or the default value)\n     */\n    public getSize(name: string, value: number): number {\n      let attributes = this.node.attributes;\n      if (attributes.isSet(name)) {\n        value = this.length2em(attributes.get(name), 1, 1); // FIXME: should use height of actual character\n      }\n      return value;\n    }\n\n    /**\n     * @param {number[]} WH  Either [W] for width, [H, D] for height and depth, or [] for min/max size\n     * @return {number}      Either the width or the total height of the character\n     */\n    public getWH(WH: number[]): number {\n      if (WH.length === 0) return 0;\n      if (WH.length === 1) return WH[0];\n      let [H, D] = WH;\n      const a = this.font.params.axis_height;\n      return (this.node.attributes.get('symmetric') ? 2 * Math.max(H - a, D + a) : H + D);\n    }\n\n    /**\n     * @param {number[]} WHD     The [W] or [H, D] being requested from the parent mrow\n     * @param {number} D         The full dimension (including symmetry, etc)\n     * @param {DelimiterData} C  The delimiter data for the stretchy character\n     */\n    public getStretchBBox(WHD: number[], D: number, C: DelimiterData) {\n      if (C.hasOwnProperty('min') && C.min > D) {\n        D = C.min;\n      }\n      let [h, d, w] = C.HDW;\n      if (this.stretch.dir === DIRECTION.Vertical) {\n        [h, d] = this.getBaseline(WHD, D, C);\n      } else {\n        w = D;\n      }\n      this.bbox.h = h;\n      this.bbox.d = d;\n      this.bbox.w = w;\n    }\n\n    /**\n     * @param {number[]} WHD     The [H, D] being requested from the parent mrow\n     * @param {number} HD        The full height (including symmetry, etc)\n     * @param {DelimiterData} C  The delimiter data for the stretchy character\n     * @return {[number, number]}        The height and depth for the vertically stretched delimiter\n     */\n    public getBaseline(WHD: number[], HD: number, C: DelimiterData): [number, number] {\n      const hasWHD = (WHD.length === 2 && WHD[0] + WHD[1] === HD);\n      const symmetric = this.node.attributes.get('symmetric');\n      const [H, D] = (hasWHD ? WHD : [HD, 0]);\n      let [h, d] = [H + D, 0];\n      if (symmetric) {\n        //\n        //  Center on the math axis\n        //\n        const a = this.font.params.axis_height;\n        if (hasWHD) {\n          h = 2 * Math.max(H - a, D + a);\n        }\n        d = h / 2 - a;\n      } else if (hasWHD) {\n        //\n        //  Use the given depth (from mrow)\n        //\n        d = D;\n      } else {\n        //\n        //  Use depth proportional to the normal-size character\n        //  (when stretching for minsize or maxsize by itself)\n        //\n        let [ch, cd] = (C.HDW || [.75, .25]);\n        d = cd * (h / (ch + cd));\n      }\n      return [h - d, d];\n    }\n\n    /**\n     * @override\n     */\n    public checkExtendedHeight(D: number, C: DelimiterData): number {\n      if (C.fullExt) {\n        const [extSize, endSize] = C.fullExt;\n        const n = Math.ceil(Math.max(0, D - endSize) / extSize);\n        D = endSize + n * extSize;\n      }\n      return D;\n    }\n\n    /**\n     * @override\n     */\n    public remapChars(chars: number[]) {\n      const primes = this.node.getProperty('primes') as string;\n      if (primes) {\n        return unicodeChars(primes);\n      }\n      if (chars.length === 1) {\n        const parent = (this.node as MmlMo).coreParent().parent;\n        const isAccent = this.isAccent && !parent.isKind('mrow');\n        const map = (isAccent ? 'accent' : 'mo');\n        const text = this.font.getRemappedChar(map, chars[0]);\n        if (text) {\n          chars = this.unicodeChars(text, this.variant);\n        }\n      }\n      return chars;\n    }\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}