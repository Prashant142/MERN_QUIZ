{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lookup = exports.separateOptions = exports.selectOptionsFromKeys = exports.selectOptions = exports.userOptions = exports.defaultOptions = exports.insert = exports.copy = exports.keys = exports.makeArray = exports.expandable = exports.Expandable = exports.OPTIONS = exports.REMOVE = exports.APPEND = exports.isObject = void 0;\nvar OBJECT = {}.constructor;\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && (obj.constructor === OBJECT || obj.constructor === Expandable);\n}\nexports.isObject = isObject;\nexports.APPEND = '[+]';\nexports.REMOVE = '[-]';\nexports.OPTIONS = {\n  invalidOption: 'warn',\n  optionError: function (message, _key) {\n    if (exports.OPTIONS.invalidOption === 'fatal') {\n      throw new Error(message);\n    }\n    console.warn('MathJax: ' + message);\n  }\n};\nvar Expandable = function () {\n  function Expandable() {}\n  return Expandable;\n}();\nexports.Expandable = Expandable;\nfunction expandable(def) {\n  return Object.assign(Object.create(Expandable.prototype), def);\n}\nexports.expandable = expandable;\nfunction makeArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nexports.makeArray = makeArray;\nfunction keys(def) {\n  if (!def) {\n    return [];\n  }\n  return Object.keys(def).concat(Object.getOwnPropertySymbols(def));\n}\nexports.keys = keys;\nfunction copy(def) {\n  var e_1, _a;\n  var props = {};\n  try {\n    for (var _b = __values(keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var key = _c.value;\n      var prop = Object.getOwnPropertyDescriptor(def, key);\n      var value = prop.value;\n      if (Array.isArray(value)) {\n        prop.value = insert([], value, false);\n      } else if (isObject(value)) {\n        prop.value = copy(value);\n      }\n      if (prop.enumerable) {\n        props[key] = prop;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);\n}\nexports.copy = copy;\nfunction insert(dst, src, warn) {\n  var e_2, _a;\n  if (warn === void 0) {\n    warn = true;\n  }\n  var _loop_1 = function (key) {\n    if (warn && dst[key] === undefined && dst.constructor !== Expandable) {\n      if (typeof key === 'symbol') {\n        key = key.toString();\n      }\n      exports.OPTIONS.optionError(\"Invalid option \\\"\".concat(key, \"\\\" (no default value).\"), key);\n      return \"continue\";\n    }\n    var sval = src[key],\n      dval = dst[key];\n    if (isObject(sval) && dval !== null && (typeof dval === 'object' || typeof dval === 'function')) {\n      var ids = keys(sval);\n      if (Array.isArray(dval) && (ids.length === 1 && (ids[0] === exports.APPEND || ids[0] === exports.REMOVE) && Array.isArray(sval[ids[0]]) || ids.length === 2 && ids.sort().join(',') === exports.APPEND + ',' + exports.REMOVE && Array.isArray(sval[exports.APPEND]) && Array.isArray(sval[exports.REMOVE]))) {\n        if (sval[exports.REMOVE]) {\n          dval = dst[key] = dval.filter(function (x) {\n            return sval[exports.REMOVE].indexOf(x) < 0;\n          });\n        }\n        if (sval[exports.APPEND]) {\n          dst[key] = __spreadArray(__spreadArray([], __read(dval), false), __read(sval[exports.APPEND]), false);\n        }\n      } else {\n        insert(dval, sval, warn);\n      }\n    } else if (Array.isArray(sval)) {\n      dst[key] = [];\n      insert(dst[key], sval, false);\n    } else if (isObject(sval)) {\n      dst[key] = copy(sval);\n    } else {\n      dst[key] = sval;\n    }\n  };\n  try {\n    for (var _b = __values(keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var key = _c.value;\n      _loop_1(key);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return dst;\n}\nexports.insert = insert;\nfunction defaultOptions(options) {\n  var defs = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    defs[_i - 1] = arguments[_i];\n  }\n  defs.forEach(function (def) {\n    return insert(options, def, false);\n  });\n  return options;\n}\nexports.defaultOptions = defaultOptions;\nfunction userOptions(options) {\n  var defs = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    defs[_i - 1] = arguments[_i];\n  }\n  defs.forEach(function (def) {\n    return insert(options, def, true);\n  });\n  return options;\n}\nexports.userOptions = userOptions;\nfunction selectOptions(options) {\n  var e_3, _a;\n  var keys = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    keys[_i - 1] = arguments[_i];\n  }\n  var subset = {};\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n      if (options.hasOwnProperty(key)) {\n        subset[key] = options[key];\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n  return subset;\n}\nexports.selectOptions = selectOptions;\nfunction selectOptionsFromKeys(options, object) {\n  return selectOptions.apply(void 0, __spreadArray([options], __read(Object.keys(object)), false));\n}\nexports.selectOptionsFromKeys = selectOptionsFromKeys;\nfunction separateOptions(options) {\n  var e_4, _a, e_5, _b;\n  var objects = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    objects[_i - 1] = arguments[_i];\n  }\n  var results = [];\n  try {\n    for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {\n      var object = objects_1_1.value;\n      var exists = {},\n        missing = {};\n      try {\n        for (var _c = (e_5 = void 0, __values(Object.keys(options || {}))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var key = _d.value;\n          (object[key] === undefined ? missing : exists)[key] = options[key];\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      results.push(exists);\n      options = missing;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n  results.unshift(options);\n  return results;\n}\nexports.separateOptions = separateOptions;\nfunction lookup(name, lookup, def) {\n  if (def === void 0) {\n    def = null;\n  }\n  return lookup.hasOwnProperty(name) ? lookup[name] : def;\n}\nexports.lookup = lookup;","map":{"version":3,"mappings":"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","names":["OBJECT","constructor","isObject","obj","Expandable","exports","invalidOption","optionError","message","_key","Error","console","warn","expandable","def","Object","assign","create","prototype","makeArray","x","Array","isArray","keys","concat","getOwnPropertySymbols","copy","props","key","prop","getOwnPropertyDescriptor","value","insert","enumerable","defineProperties","dst","src","undefined","toString","sval","dval","ids","length","sort","join","filter","indexOf","defaultOptions","options","_i","defs","forEach","userOptions","selectOptions","subset","hasOwnProperty","selectOptionsFromKeys","object","separateOptions","objects","results","exists","missing","push","unshift","lookup","name"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/util/Options.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements functions for handling option lists\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n\n/*****************************************************************/\n/* tslint:disable-next-line:jsdoc-require */\nconst OBJECT = {}.constructor;\n\n/**\n *  Check if an object is an object literal (as opposed to an instance of a class)\n */\nexport function isObject(obj: any) {\n  return typeof obj === 'object' && obj !== null &&\n    (obj.constructor === OBJECT || obj.constructor === Expandable);\n}\n\n/*****************************************************************/\n/**\n * Generic list of options\n */\nexport type OptionList = {[name: string]: any};\n\n/*****************************************************************/\n/**\n *  Used to append an array to an array in default options\n *  E.g., an option of the form\n *\n *    {\n *      name: {[APPEND]: [1, 2, 3]}\n *    }\n *\n *  where 'name' is an array in the default options would end up with name having its\n *  original value with 1, 2, and 3 appended.\n */\nexport const APPEND = '[+]';\n\n/**\n *  Used to remove elements from an array in default options\n *  E.g., an option of the form\n *\n *    {\n *      name: {[REMOVE]: [2]}\n *    }\n *\n *  where 'name' is an array in the default options would end up with name having its\n *  original value but with any entry of 2 removed  So if the original value was [1, 2, 3, 2],\n *  then the final value will be [1, 3] instead.\n */\nexport const REMOVE = '[-]';\n\n\n/**\n *  Provides options for the option utlities.\n */\nexport const OPTIONS = {\n  invalidOption: 'warn' as ('fatal' | 'warn'),\n  /**\n   * Function to report messages for invalid options\n   *\n   * @param {string} message   The message for the invalid parameter.\n   * @param {string} key       The invalid key itself.\n   */\n  optionError: (message: string, _key: string) => {\n    if (OPTIONS.invalidOption === 'fatal') {\n      throw new Error(message);\n    }\n    console.warn('MathJax: ' + message);\n  }\n};\n\n\n/**\n * A Class to use for options that should not produce warnings if an undefined key is used\n */\nexport class Expandable {}\n\n/**\n * Produces an instance of Expandable with the given values (to be used in defining options\n * that can use keys that don't have default values).  E.g., default options of the form:\n *\n *  OPTIONS = {\n *     types: expandable({\n *       a: 1,\n *       b: 2\n *     })\n *  }\n *\n *  would allow user options of\n *\n *  {\n *     types: {\n *       c: 3\n *     }\n *  }\n *\n *  without reporting an error.\n */\nexport function expandable(def: OptionList) {\n  return Object.assign(Object.create(Expandable.prototype), def);\n}\n\n/*****************************************************************/\n/**\n *  Make sure an option is an Array\n */\nexport function makeArray(x: any): any[] {\n  return Array.isArray(x) ? x : [x];\n}\n\n/*****************************************************************/\n/**\n * Get all keys and symbols from an object\n *\n * @param {Optionlist} def        The object whose keys are to be returned\n * @return {(string | symbol)[]}  The list of keys for the object\n */\nexport function keys(def: OptionList): (string | symbol)[] {\n  if (!def) {\n    return [];\n  }\n  return (Object.keys(def) as (string | symbol)[]).concat(Object.getOwnPropertySymbols(def));\n}\n\n/*****************************************************************/\n/**\n * Make a deep copy of an object\n *\n * @param {OptionList} def  The object to be copied\n * @return {OptionList}     The copy of the object\n */\nexport function copy(def: OptionList): OptionList {\n  let props: OptionList = {};\n  for (const key of keys(def)) {\n    let prop = Object.getOwnPropertyDescriptor(def, key);\n    let value = prop.value;\n    if (Array.isArray(value)) {\n      prop.value = insert([], value, false);\n    } else if (isObject(value)) {\n      prop.value = copy(value);\n    }\n    if (prop.enumerable) {\n      props[key as string] = prop;\n    }\n  }\n  return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);\n}\n\n/*****************************************************************/\n/**\n * Insert one object into another (with optional warnings about\n * keys that aren't in the original)\n *\n * @param {OptionList} dst  The option list to merge into\n * @param {OptionList} src  The options to be merged\n * @param {boolean} warn    True if a warning should be issued for a src option that isn't already in dst\n * @return {OptionList}     The modified destination option list (dst)\n */\nexport function insert(dst: OptionList, src: OptionList, warn: boolean = true): OptionList {\n  for (let key of keys(src) as string[]) {\n    //\n    // Check if the key is valid (i.e., is in the defaults or in an expandable block)\n    //\n    if (warn && dst[key] === undefined && dst.constructor !== Expandable) {\n      if (typeof key === 'symbol') {\n        key = (key as symbol).toString();\n      }\n      OPTIONS.optionError(`Invalid option \"${key}\" (no default value).`, key);\n      continue;\n    }\n    //\n    // Shorthands for the source and destination values\n    //\n    let sval = src[key], dval = dst[key];\n    //\n    // If the source is an object literal and the destination exists and is either an\n    //   object or a function (so can have properties added to it)...\n    //\n    if (isObject(sval) && dval !== null &&\n        (typeof dval === 'object' || typeof dval === 'function')) {\n      const ids = keys(sval);\n      //\n      // Check for APPEND or REMOVE objects:\n      //\n      if (\n        //\n        // If the destination value is an array...\n        //\n        Array.isArray(dval) &&\n          (\n            //\n            // If there is only one key and it is APPEND or REMOVE and the keys value is an array...\n            //\n            (ids.length === 1 && (ids[0] === APPEND || ids[0] === REMOVE) && Array.isArray(sval[ids[0]])) ||\n              //\n              // Or if there are two keys and they are APPEND and REMOVE and both keys' values\n              //   are arrays...\n              //\n              (ids.length === 2 && ids.sort().join(',') === APPEND + ',' + REMOVE &&\n               Array.isArray(sval[APPEND]) && Array.isArray(sval[REMOVE]))\n          )\n      ) {\n        //\n        // Then remove any values to be removed\n        //\n        if (sval[REMOVE]) {\n          dval = dst[key] = dval.filter(x => sval[REMOVE].indexOf(x) < 0);\n        }\n        //\n        // And append any values to be added (make a copy so as not to modify the original)\n        //\n        if (sval[APPEND]) {\n          dst[key] = [...dval, ...sval[APPEND]];\n        }\n      } else {\n        //\n        // Otherwise insert the values of the source object into the destination object\n        //\n        insert(dval, sval, warn);\n      }\n    } else if (Array.isArray(sval)) {\n      //\n      // If the source is an array, replace the destination with an empty array\n      //   and copy the source values into it.\n      //\n      dst[key] = [];\n      insert(dst[key], sval, false);\n    } else if (isObject(sval)) {\n      //\n      // If the source is an object literal, set the destination to a copy of it\n      //\n      dst[key] = copy(sval);\n    } else {\n      //\n      // Otherwise set the destination to the source value\n      //\n      dst[key] = sval;\n    }\n  }\n  return dst;\n}\n\n/*****************************************************************/\n/**\n * Merge options without warnings (so we can add new default values into an\n * existing default list)\n *\n * @param {OptionList} options  The option list to be merged into\n * @param {OptionList[]} defs   The option lists to merge into the first one\n * @return {OptionList}         The modified options list\n */\nexport function defaultOptions(options: OptionList, ...defs: OptionList[]): OptionList {\n  defs.forEach(def => insert(options, def, false));\n  return options;\n}\n\n/*****************************************************************/\n/**\n * Merge options with warnings about undefined ones (so we can merge\n * user options into the default list)\n *\n * @param {OptionList} options  The option list to be merged into\n * @param {OptionList[]} defs   The option lists to merge into the first one\n * @return {OptionList}         The modified options list\n */\nexport function userOptions(options: OptionList, ...defs: OptionList[]): OptionList {\n  defs.forEach(def => insert(options, def, true));\n  return options;\n}\n\n/*****************************************************************/\n/**\n * Select a subset of options by key name\n *\n * @param {OptionList} options  The option list from which option values will be taken\n * @param {string[]} keys       The names of the options to extract\n * @return {OptionList}         The option list consisting of only the ones whose keys were given\n */\nexport function selectOptions(options: OptionList, ...keys: string[]): OptionList {\n  let subset: OptionList = {};\n  for (const key of keys) {\n    if (options.hasOwnProperty(key)) {\n      subset[key] = options[key];\n    }\n  }\n  return subset;\n}\n\n/*****************************************************************/\n/**\n * Select a subset of options by keys from an object\n *\n * @param {OptionList} options  The option list from which the option values will be taken\n * @param {OptionList} object   The option list whose keys will be used to select the options\n * @return {OptionList}         The option list consisting of the option values from the first\n *                               list whose keys are those from the second list.\n */\nexport function selectOptionsFromKeys(options: OptionList, object: OptionList): OptionList {\n  return selectOptions(options, ...Object.keys(object));\n}\n\n/*****************************************************************/\n/**\n *  Separate options into sets: the ones having the same keys\n *  as the second object, the third object, etc, and the ones that don't.\n *  (Used to separate an option list into the options needed for several\n *   subobjects.)\n *\n * @param {OptionList} options    The option list to be split into parts\n * @param {OptionList[]} objects  The list of option lists whose keys are used to break up\n *                                 the original options into separate pieces.\n * @return {OptionList[]}         The option lists taken from the original based on the\n *                                 keys of the other objects.  The first one in the list\n *                                 consists of the values not appearing in any of the others\n *                                 (i.e., whose keys were not in any of the others).\n */\nexport function separateOptions(options: OptionList, ...objects: OptionList[]): OptionList[] {\n  let results: OptionList[] = [];\n  for (const object of objects) {\n    let exists: OptionList = {}, missing: OptionList = {};\n    for (const key of Object.keys(options || {})) {\n      (object[key] === undefined ? missing : exists)[key] = options[key];\n    }\n    results.push(exists);\n    options = missing;\n  }\n  results.unshift(options);\n  return results;\n}\n\n\n/*****************************************************************/\n/**\n *  Look up a value from object literal, being sure it is an\n *  actual property (not inherited), with a default if not found.\n *\n * @param {string} name         The name of the key to look up.\n * @param {OptionList} lookup   The list of options to check.\n * @param {any} def             The default value if the key isn't found.\n */\nexport function lookup(name: string, lookup: OptionList, def: any = null) {\n  return (lookup.hasOwnProperty(name) ? lookup[name] : def);\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}