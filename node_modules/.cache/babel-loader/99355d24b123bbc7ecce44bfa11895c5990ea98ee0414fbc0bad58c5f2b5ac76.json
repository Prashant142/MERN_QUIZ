{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XMLNode = exports.TextNode = exports.AbstractMmlEmptyNode = exports.AbstractMmlBaseNode = exports.AbstractMmlLayoutNode = exports.AbstractMmlTokenNode = exports.AbstractMmlNode = exports.indentAttributes = exports.TEXCLASSNAMES = exports.TEXCLASS = void 0;\nvar Attributes_js_1 = require(\"./Attributes.js\");\nvar Node_js_1 = require(\"../Tree/Node.js\");\nexports.TEXCLASS = {\n  ORD: 0,\n  OP: 1,\n  BIN: 2,\n  REL: 3,\n  OPEN: 4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,\n  NONE: -1\n};\nexports.TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\nvar TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\nvar TEXSPACE = [[0, -1, 2, 3, 0, 0, 0, 1], [-1, -1, 0, 3, 0, 0, 0, 1], [2, 2, 0, 0, 2, 0, 0, 2], [3, 3, 0, 0, 3, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, -1, 2, 3, 0, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, -1, 2, 3, 1, 0, 1, 1]];\nexports.indentAttributes = ['indentalign', 'indentalignfirst', 'indentshift', 'indentshiftfirst'];\nvar AbstractMmlNode = function (_super) {\n  __extends(AbstractMmlNode, _super);\n  function AbstractMmlNode(factory, attributes, children) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (children === void 0) {\n      children = [];\n    }\n    var _this = _super.call(this, factory) || this;\n    _this.prevClass = null;\n    _this.prevLevel = null;\n    _this.texclass = null;\n    if (_this.arity < 0) {\n      _this.childNodes = [factory.create('inferredMrow')];\n      _this.childNodes[0].parent = _this;\n    }\n    _this.setChildren(children);\n    _this.attributes = new Attributes_js_1.Attributes(factory.getNodeClass(_this.kind).defaults, factory.getNodeClass('math').defaults);\n    _this.attributes.setList(attributes);\n    return _this;\n  }\n  AbstractMmlNode.prototype.copy = function (keepIds) {\n    var e_1, _a, e_2, _b;\n    if (keepIds === void 0) {\n      keepIds = false;\n    }\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n    if (this.attributes) {\n      var attributes = this.attributes.getAllAttributes();\n      try {\n        for (var _c = __values(Object.keys(attributes)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          if (name_1 !== 'id' || keepIds) {\n            node.attributes.set(name_1, attributes[name_1]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      var children = this.childNodes;\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes;\n      }\n      try {\n        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n          var child = children_1_1.value;\n          if (child) {\n            node.appendChild(child.copy());\n          } else {\n            node.childNodes.push(null);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    return node;\n  };\n  Object.defineProperty(AbstractMmlNode.prototype, \"texClass\", {\n    get: function () {\n      return this.texclass;\n    },\n    set: function (texClass) {\n      this.texclass = texClass;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"arity\", {\n    get: function () {\n      return Infinity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"Parent\", {\n    get: function () {\n      var parent = this.parent;\n      while (parent && parent.notParent) {\n        parent = parent.Parent;\n      }\n      return parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlNode.prototype.setChildren = function (children) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return _super.prototype.setChildren.call(this, children);\n  };\n  AbstractMmlNode.prototype.appendChild = function (child) {\n    var e_3, _a;\n    var _this = this;\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      if (this.arity === Infinity) {\n        child.childNodes.forEach(function (node) {\n          return _super.prototype.appendChild.call(_this, node);\n        });\n        return child;\n      }\n      var original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      try {\n        for (var _b = __values(original.getPropertyNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_2 = _c.value;\n          child.setProperty(name_2, original.getProperty(name_2));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n    return _super.prototype.appendChild.call(this, child);\n  };\n  AbstractMmlNode.prototype.replaceChild = function (newChild, oldChild) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return _super.prototype.replaceChild.call(this, newChild, oldChild);\n  };\n  AbstractMmlNode.prototype.core = function () {\n    return this;\n  };\n  AbstractMmlNode.prototype.coreMO = function () {\n    return this;\n  };\n  AbstractMmlNode.prototype.coreIndex = function () {\n    return 0;\n  };\n  AbstractMmlNode.prototype.childPosition = function () {\n    var e_4, _a;\n    var child = this;\n    var parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      var i = 0;\n      try {\n        for (var _b = __values(parent.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var node = _c.value;\n          if (node === child) {\n            return i;\n          }\n          i++;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n    return null;\n  };\n  AbstractMmlNode.prototype.setTeXclass = function (prev) {\n    this.getPrevClass(prev);\n    return this.texClass != null ? this : prev;\n  };\n  AbstractMmlNode.prototype.updateTeXclass = function (core) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  };\n  AbstractMmlNode.prototype.getPrevClass = function (prev) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel');\n    }\n  };\n  AbstractMmlNode.prototype.texSpacing = function () {\n    var prevClass = this.prevClass != null ? this.prevClass : exports.TEXCLASS.NONE;\n    var texClass = this.texClass || exports.TEXCLASS.ORD;\n    if (prevClass === exports.TEXCLASS.NONE || texClass === exports.TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === exports.TEXCLASS.VCENTER) {\n      prevClass = exports.TEXCLASS.ORD;\n    }\n    if (texClass === exports.TEXCLASS.VCENTER) {\n      texClass = exports.TEXCLASS.ORD;\n    }\n    var space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  };\n  AbstractMmlNode.prototype.hasSpacingAttributes = function () {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  };\n  AbstractMmlNode.prototype.setInheritedAttributes = function (attributes, display, level, prime) {\n    var e_5, _a;\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (display === void 0) {\n      display = false;\n    }\n    if (level === void 0) {\n      level = 0;\n    }\n    if (prime === void 0) {\n      prime = false;\n    }\n    var defaults = this.attributes.getAllDefaults();\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n          var _d = __read(attributes[key], 2),\n            node = _d[0],\n            value = _d[1];\n          var noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n          if (!noinherit[key]) {\n            this.attributes.setInherited(key, value);\n          }\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    var displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    var scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    var arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  };\n  AbstractMmlNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_6, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n  AbstractMmlNode.prototype.addInheritedAttributes = function (current, attributes) {\n    var e_7, _a;\n    var updated = __assign({}, current);\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_3 = _c.value;\n        if (name_3 !== 'displaystyle' && name_3 !== 'scriptlevel' && name_3 !== 'style') {\n          updated[name_3] = [this.kind, attributes[name_3]];\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n    return updated;\n  };\n  AbstractMmlNode.prototype.inheritAttributesFrom = function (node) {\n    var attributes = node.attributes;\n    var display = attributes.get('displaystyle');\n    var scriptlevel = attributes.get('scriptlevel');\n    var defaults = !attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    };\n    var prime = node.getProperty('texprimestyle') || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  };\n  AbstractMmlNode.prototype.verifyTree = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    var arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  };\n  AbstractMmlNode.prototype.verifyAttributes = function (options) {\n    var e_8, _a;\n    if (options['checkAttributes']) {\n      var attributes = this.attributes;\n      var bad = [];\n      try {\n        for (var _b = __values(attributes.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_4 = _c.value;\n          if (name_4.substr(0, 5) !== 'data-' && attributes.getDefault(name_4) === undefined && !name_4.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n            bad.push(name_4);\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  };\n  AbstractMmlNode.prototype.verifyChildren = function (options) {\n    var e_9, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.verifyTree(options);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n  AbstractMmlNode.prototype.mError = function (message, options, short) {\n    if (short === void 0) {\n      short = false;\n    }\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    var merror = this.factory.create('merror');\n    merror.attributes.set('data-mjx-message', message);\n    if (options['fullErrors'] || short) {\n      var mtext = this.factory.create('mtext');\n      var text = this.factory.create('text');\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  };\n  AbstractMmlNode.defaults = {\n    mathbackground: Attributes_js_1.INHERIT,\n    mathcolor: Attributes_js_1.INHERIT,\n    mathsize: Attributes_js_1.INHERIT,\n    dir: Attributes_js_1.INHERIT\n  };\n  AbstractMmlNode.noInherit = {\n    mstyle: {\n      mpadded: {\n        width: true,\n        height: true,\n        depth: true,\n        lspace: true,\n        voffset: true\n      },\n      mtable: {\n        width: true,\n        height: true,\n        depth: true,\n        align: true\n      }\n    },\n    maligngroup: {\n      mrow: {\n        groupalign: true\n      },\n      mtable: {\n        groupalign: true\n      }\n    }\n  };\n  AbstractMmlNode.alwaysInherit = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n  AbstractMmlNode.verifyDefaults = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n  return AbstractMmlNode;\n}(Node_js_1.AbstractNode);\nexports.AbstractMmlNode = AbstractMmlNode;\nvar AbstractMmlTokenNode = function (_super) {\n  __extends(AbstractMmlTokenNode, _super);\n  function AbstractMmlTokenNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlTokenNode.prototype, \"isToken\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlTokenNode.prototype.getText = function () {\n    var e_10, _a;\n    var text = '';\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof TextNode) {\n          text += child.getText();\n        }\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n    return text;\n  };\n  AbstractMmlTokenNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_11, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof AbstractMmlNode) {\n          child.setInheritedAttributes(attributes, display, level, prime);\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n  };\n  AbstractMmlTokenNode.prototype.walkTree = function (func, data) {\n    var e_12, _a;\n    func(this, data);\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof AbstractMmlNode) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n    return data;\n  };\n  AbstractMmlTokenNode.defaults = __assign(__assign({}, AbstractMmlNode.defaults), {\n    mathvariant: 'normal',\n    mathsize: Attributes_js_1.INHERIT\n  });\n  return AbstractMmlTokenNode;\n}(AbstractMmlNode);\nexports.AbstractMmlTokenNode = AbstractMmlTokenNode;\nvar AbstractMmlLayoutNode = function (_super) {\n  __extends(AbstractMmlLayoutNode, _super);\n  function AbstractMmlLayoutNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return this.childNodes[0].isSpacelike;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"arity\", {\n    get: function () {\n      return -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlLayoutNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n  AbstractMmlLayoutNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n  AbstractMmlLayoutNode.prototype.setTeXclass = function (prev) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  };\n  AbstractMmlLayoutNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlLayoutNode;\n}(AbstractMmlNode);\nexports.AbstractMmlLayoutNode = AbstractMmlLayoutNode;\nvar AbstractMmlBaseNode = function (_super) {\n  __extends(AbstractMmlBaseNode, _super);\n  function AbstractMmlBaseNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlBaseNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlBaseNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n  AbstractMmlBaseNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n  AbstractMmlBaseNode.prototype.setTeXclass = function (prev) {\n    var e_13, _a;\n    this.getPrevClass(prev);\n    this.texClass = exports.TEXCLASS.ORD;\n    var base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    try {\n      for (var _b = __values(this.childNodes.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child) {\n          child.setTeXclass(null);\n        }\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n    return prev;\n  };\n  AbstractMmlBaseNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlBaseNode;\n}(AbstractMmlNode);\nexports.AbstractMmlBaseNode = AbstractMmlBaseNode;\nvar AbstractMmlEmptyNode = function (_super) {\n  __extends(AbstractMmlEmptyNode, _super);\n  function AbstractMmlEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"arity\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"Parent\", {\n    get: function () {\n      return this.parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"texClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevLevel\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlEmptyNode.prototype.hasSpacingAttributes = function () {\n    return false;\n  };\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"attributes\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlEmptyNode.prototype.core = function () {\n    return this;\n  };\n  AbstractMmlEmptyNode.prototype.coreMO = function () {\n    return this;\n  };\n  AbstractMmlEmptyNode.prototype.coreIndex = function () {\n    return 0;\n  };\n  AbstractMmlEmptyNode.prototype.childPosition = function () {\n    return 0;\n  };\n  AbstractMmlEmptyNode.prototype.setTeXclass = function (prev) {\n    return prev;\n  };\n  AbstractMmlEmptyNode.prototype.texSpacing = function () {\n    return '';\n  };\n  AbstractMmlEmptyNode.prototype.setInheritedAttributes = function (_attributes, _display, _level, _prime) {};\n  AbstractMmlEmptyNode.prototype.inheritAttributesFrom = function (_node) {};\n  AbstractMmlEmptyNode.prototype.verifyTree = function (_options) {};\n  AbstractMmlEmptyNode.prototype.mError = function (_message, _options, _short) {\n    if (_short === void 0) {\n      _short = false;\n    }\n    return null;\n  };\n  return AbstractMmlEmptyNode;\n}(Node_js_1.AbstractEmptyNode);\nexports.AbstractMmlEmptyNode = AbstractMmlEmptyNode;\nvar TextNode = function (_super) {\n  __extends(TextNode, _super);\n  function TextNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.text = '';\n    return _this;\n  }\n  Object.defineProperty(TextNode.prototype, \"kind\", {\n    get: function () {\n      return 'text';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TextNode.prototype.getText = function () {\n    return this.text;\n  };\n  TextNode.prototype.setText = function (text) {\n    this.text = text;\n    return this;\n  };\n  TextNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setText(this.getText());\n  };\n  TextNode.prototype.toString = function () {\n    return this.text;\n  };\n  return TextNode;\n}(AbstractMmlEmptyNode);\nexports.TextNode = TextNode;\nvar XMLNode = function (_super) {\n  __extends(XMLNode, _super);\n  function XMLNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.xml = null;\n    _this.adaptor = null;\n    return _this;\n  }\n  Object.defineProperty(XMLNode.prototype, \"kind\", {\n    get: function () {\n      return 'XML';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  XMLNode.prototype.getXML = function () {\n    return this.xml;\n  };\n  XMLNode.prototype.setXML = function (xml, adaptor) {\n    if (adaptor === void 0) {\n      adaptor = null;\n    }\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  };\n  XMLNode.prototype.getSerializedXML = function () {\n    return this.adaptor.serializeXML(this.xml);\n  };\n  XMLNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setXML(this.adaptor.clone(this.xml));\n  };\n  XMLNode.prototype.toString = function () {\n    return 'XML data';\n  };\n  return XMLNode;\n}(AbstractMmlEmptyNode);\nexports.XMLNode = XMLNode;","map":{"version":3,"mappings":"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","names":["exports","ORD","OP","BIN","REL","OPEN","CLOSE","PUNCT","INNER","VCENTER","NONE","TEXSPACELENGTH","TEXSPACE","__extends","factory","attributes","children","_super","_this","arity","childNodes","create","parent","setChildren","Attributes_js_1","getNodeClass","kind","defaults","setList","AbstractMmlNode","keepIds","node","properties","getAllAttributes","keys","name_1","set","length","isInferred","child","appendChild","copy","push","Object","texclass","texClass","Infinity","notParent","Parent","forEach","original","getPropertyNames","name_2","setProperty","getProperty","newChild","oldChild","replaceChild","i","prev","getPrevClass","core","prevClass","prevLevel","get","space","Math","abs","isEmbellished","coreMO","hasSpacingAttributes","display","level","prime","getAllDefaults","key","hasOwnProperty","alwaysInherit","value","noinherit","noInherit","setInherited","displaystyle","getExplicit","undefined","scriptlevel","slice","setChildInheritedAttributes","setInheritedAttributes","current","updated","name_3","isSet","mathsize","options","verifyAttributes","mError","verifyChildren","bad","getExplicitNames","name_4","substr","getDefault","match","join","verifyTree","message","short","isKind","merror","mtext","text","setText","mathbackground","mathcolor","dir","mstyle","mpadded","width","height","depth","lspace","voffset","mtable","align","maligngroup","mrow","groupalign","scriptminsize","scriptsizemultiplier","checkArity","checkAttributes","fullErrors","fixMmultiscripts","fixMtables","Node_js_1","AbstractMmlTokenNode","TextNode","getText","func","data","walkTree","mathvariant","AbstractMmlLayoutNode","isSpacelike","setTeXclass","updateTeXclass","AbstractMmlBaseNode","base","AbstractMmlEmptyNode","_attributes","_display","_level","_prime","_node","_options","_message","_short","XMLNode","xml","adaptor","serializeXML","setXML","clone"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/core/MmlTree/MmlNode.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Interfaces and abstract classes for MmlNode objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Attributes, INHERIT} from './Attributes.js';\nimport {Property, PropertyList, Node, AbstractNode, AbstractEmptyNode, NodeClass} from '../Tree/Node.js';\nimport {MmlFactory} from './MmlFactory.js';\nimport {DOMAdaptor} from '../DOMAdaptor.js';\n\n/**\n *  Used in setInheritedAttributes() to pass originating node kind as well as property value\n */\nexport type AttributeList = {[attribute: string]: [string, Property]};\n\n/**\n *  These are the TeX classes for spacing computations\n */\nexport const TEXCLASS = {\n  ORD:   0,\n  OP:    1,\n  BIN:   2,\n  REL:   3,\n  OPEN:  4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,  // Used in TeXAtom, but not for spacing\n  NONE:   -1\n};\n\nexport const TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\n\n/**\n *  The spacing sizes used by the TeX spacing table below.\n */\nconst TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\n\n/**\n * See TeXBook Chapter 18 (p. 170)\n */\nconst TEXSPACE = [\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // ORD\n  [-1, -1,  0,  3,  0,  0,  0,  1], // OP\n  [ 2,  2,  0,  0,  2,  0,  0,  2], // BIN\n  [ 3,  3,  0,  0,  3,  0,  0,  3], // REL\n  [ 0,  0,  0,  0,  0,  0,  0,  0], // OPEN\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // CLOSE\n  [ 1,  1,  0,  1,  1,  1,  1,  1], // PUNCT\n  [ 1, -1,  2,  3,  1,  0,  1,  1]  // INNER\n];\n\n/**\n * Attributes used to determine indentation and shifting\n */\nexport const indentAttributes = [\n  'indentalign', 'indentalignfirst',\n  'indentshift', 'indentshiftfirst'\n];\n\n/**\n * The nodes that can be in the internal MathML tree\n */\nexport type MMLNODE = MmlNode | TextNode | XMLNode;\n\n/*****************************************************************/\n/**\n *  The MmlNode interface (extends Node interface)\n */\n\nexport interface MmlNode extends Node {\n\n  /**\n   * Test various properties of MathML nodes\n   */\n  readonly isToken: boolean;\n  readonly isEmbellished: boolean;\n  readonly isSpacelike: boolean;\n  readonly linebreakContainer: boolean;\n  readonly hasNewLine: boolean;\n\n  /**\n   *  The expected number of children (-1 means use inferred mrow)\n   */\n  readonly arity: number;\n  readonly isInferred: boolean;\n\n  /**\n   *  Get the parent node (skipping inferred mrows and\n   *    other nodes marked as notParent)\n   */\n  readonly Parent: MmlNode;\n  readonly notParent: boolean;\n\n  /**\n   * The actual parent in the tree\n   */\n  parent: MmlNode;\n\n  /**\n   *  values needed for TeX spacing computations\n   */\n  texClass: number;\n  prevClass: number;\n  prevLevel: number;\n\n  /**\n   *  The attributes (explicit and inherited) for this node\n   */\n  attributes: Attributes;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the child node that contains the\n   *                    core <mo> node.  For non-embellished nodes, the original node.\n   */\n  core(): MmlNode;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the core <mo> element (at whatever\n   *                    depth).  For non-embellished nodes, the original node itself.\n   */\n  coreMO(): MmlNode;\n\n  /**\n   * @return {number}   For embellished operators, the index of the child node containing\n   *                    the core <mo>.  For non-embellished nodes, 0.\n   */\n  coreIndex(): number;\n\n  /**\n   * @return {number}  The index of this node in its parent's childNodes array.\n   */\n  childPosition(): number;\n\n  /**\n   * @param {MmlNode} prev  The node that is before this one for TeX spacing purposes\n   *                        (not all nodes count in TeX measurements)\n   * @return {MmlNode}  The node that should be the previous node for the next one\n   *                    in the tree (usually, either the last child, or the node itself)\n   */\n  setTeXclass(prev: MmlNode): MmlNode;\n\n  /**\n   * @return {string}  The spacing to use before this element (one of TEXSPACELENGTH array above)\n   */\n  texSpacing(): string;\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form', 'lspace', or 'rspace' attribute\n   */\n  hasSpacingAttributes(): boolean;\n\n  /**\n   * Sets the nodes inherited attributes, and pushes them to the nodes children.\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  setInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean): void;\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  inheritAttributesFrom(node: MmlNode): void;\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   * @return {MmlNode}               The construted merror\n   */\n  mError(message: string, options: PropertyList, short?: boolean): MmlNode;\n\n  /**\n   * Check integrity of MathML structure\n   *\n   * @param {PropertyList} options  The options controlling the check\n   */\n  verifyTree(options?: PropertyList): void;\n}\n\n\n/*****************************************************************/\n/**\n *  The MmlNode class interface (extends the NodeClass)\n */\n\nexport interface MmlNodeClass extends NodeClass {\n\n  /**\n   *  The list of default attribute values for nodes of this class\n   */\n  defaults?: PropertyList;\n\n  /**\n   * An MmlNode takes a NodeFactory (so it can create additional nodes as needed), a list\n   *   of attributes, and an array of children and returns the desired MmlNode with\n   *   those attributes and children\n   *\n   * @constructor\n   * @param {MmlFactory} factory       The MathML node factory to use to create additional nodes\n   * @param {PropertyList} attributes  The list of initial attributes for the node\n   * @param {MmlNode[]} children       The initial child nodes (more can be added later)\n   */\n  new (factory: MmlFactory, attributes?: PropertyList, children?: MmlNode[]): MmlNode;\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode class (extends the AbstractNode class and implements\n *  the IMmlNode interface)\n */\n\nexport abstract class AbstractMmlNode extends AbstractNode implements MmlNode {\n\n  /**\n   * The properties common to all MathML nodes\n   */\n  public static defaults: PropertyList = {\n    mathbackground: INHERIT,\n    mathcolor: INHERIT,\n    mathsize: INHERIT,  // technically only for token elements, but <mstyle mathsize=\"...\"> should\n    //    scale all spaces, fractions, etc.\n    dir: INHERIT\n  };\n\n  /**\n   *  This lists properties that do NOT get inherited between specific kinds\n   *  of nodes.  The outer keys are the node kinds that are being inherited FROM,\n   *  while the second level of keys are the nodes that INHERIT the values.  Any\n   *  property appearing in the innermost list is NOT inherited by the pair.\n   *\n   *  For example, an mpadded element will not inherit a width attribute from an mstyle node.\n   */\n  public static noInherit: {[node1: string]: {[node2: string]: {[attribute: string]: boolean}}} = {\n    mstyle: {\n      mpadded: {width: true, height: true, depth: true, lspace: true, voffset: true},\n      mtable:  {width: true, height: true, depth: true, align: true}\n    },\n    maligngroup: {\n      mrow: {groupalign: true},\n      mtable: {groupalign: true}\n    }\n  };\n\n  /**\n   * This lists the attributes that should always be inherited,\n   *   even when there is no default value for the attribute.\n   */\n  public static alwaysInherit: {[name: string]: boolean} = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n\n  /**\n   * This is the list of options for the verifyTree() method\n   */\n  public static verifyDefaults: PropertyList = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n\n  /*\n   * These default to being unset (the node doesn't participate in spacing calculations).\n   * The correct values are produced when the setTeXclass() method is called on the tree.\n   */\n\n  /**\n   * The TeX class for the preceding node\n   */\n  public prevClass: number = null;\n\n  /**\n   * The scriptlevel of the preceding node\n   */\n  public prevLevel: number = null;\n\n  /**\n   * This node's attributes\n   */\n  public attributes: Attributes;\n\n  /**\n   *  Child nodes are MmlNodes (special case of Nodes).\n   */\n  public childNodes: MmlNode[];\n\n  /**\n   * The parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * The node factory is an MmlFactory\n   */\n  public readonly factory: MmlFactory;\n\n  /**\n   * The TeX class of this node (obtained via texClass below)\n   */\n  protected texclass: number = null;\n\n  /**\n   *  Create an MmlNode:\n   *    If the arity is -1, add the inferred row (created by the factory)\n   *    Add the children, if any\n   *    Create the Attribute object from the class defaults and the global defaults (the math node defaults)\n   *\n   *  @override\n   */\n  constructor(factory: MmlFactory, attributes: PropertyList = {}, children: MmlNode[] = []) {\n    super(factory);\n    if (this.arity < 0) {\n      this.childNodes = [factory.create('inferredMrow')];\n      this.childNodes[0].parent = this;\n    }\n    this.setChildren(children);\n    this.attributes = new Attributes(\n      factory.getNodeClass(this.kind).defaults,\n      factory.getNodeClass('math').defaults\n    );\n    this.attributes.setList(attributes);\n  }\n\n  /**\n   * @override\n   *\n   * @param {boolean} keepIds   True to copy id attributes, false to skip them.\n   *                              (May cause error in the future, since not part of the interface.)\n   * @return {AbstractMmlNode}  The copied node tree.\n   */\n  public copy(keepIds: boolean = false): AbstractMmlNode {\n    const node = this.factory.create(this.kind) as AbstractMmlNode;\n    node.properties = {...this.properties};\n    if (this.attributes) {\n      const attributes = this.attributes.getAllAttributes();\n      for (const name of Object.keys(attributes)) {\n        if (name !== 'id' || keepIds) {\n          node.attributes.set(name, attributes[name]);\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      let children = this.childNodes as MmlNode[];\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes as MmlNode[];\n      }\n      for (const child of children) {\n        if (child) {\n          node.appendChild(child.copy() as MmlNode);\n        } else {\n          node.childNodes.push(null);\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public get texClass(): number {\n    return this.texclass;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public set texClass(texClass: number) {\n    this.texclass = texClass;\n  }\n\n  /**\n   * @return {boolean}  true if this is a token node\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is an embellished operator\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a space-like node\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that supports linebreaks in its children\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this node contains a line break\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  The number of children allowed, or Infinity for any number,\n   *                   or -1 for when an inferred row is needed for the children.\n   *                   Special case is 1, meaning at least one (other numbers\n   *                   mean exactly that many).\n   */\n  public get arity(): number {\n    return Infinity;\n  }\n\n  /**\n   * @return {boolean}  true if this is an inferred mrow\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  The logical parent of this node (skipping over inferred rows\n   *                      some other node types)\n   */\n  public get Parent(): MmlNode {\n    let parent = this.parent;\n    while (parent && parent.notParent) {\n      parent = parent.Parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that doesn't count as a parent node in Parent()\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * If there is an inferred row, the the children of that instead\n   *\n   * @override\n   */\n  public setChildren(children: MmlNode[]) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return super.setChildren(children);\n  }\n  /**\n   * If there is an inferred row, append to that instead.\n   * If a child is inferred, append its children instead.\n   *\n   * @override\n   */\n  public appendChild(child: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      //\n      //  If we can have arbitrary children, remove the inferred mrow\n      //  (just add its children).\n      //\n      if (this.arity === Infinity) {\n        child.childNodes.forEach((node) => super.appendChild(node));\n        return child;\n      }\n      //\n      //  Otherwise, convert the inferred mrow to an explicit mrow\n      //\n      const original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      for (const name of original.getPropertyNames()) {\n        child.setProperty(name, original.getProperty(name));\n      }\n    }\n    return super.appendChild(child);\n  }\n  /**\n   * If there is an inferred row, remove the child from there\n   *\n   * @override\n   */\n  public replaceChild(newChild: MmlNode, oldChild: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return super.replaceChild(newChild, oldChild);\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    let child: MmlNode = this;\n    let parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      let i = 0;\n      for (const node of parent.childNodes) {\n        if (node === child) {\n          return i;\n        }\n        i++;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode): MmlNode {\n    this.getPrevClass(prev);\n    return (this.texClass != null ? this : prev);\n  }\n  /**\n   * For embellished operators, get the data from the core and clear the core\n   *\n   * @param {MmlNode} core  The core <mo> for this node\n   */\n  protected updateTeXclass(core: MmlNode) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  }\n  /**\n   * Get the previous element's texClass and scriptlevel\n   *\n   * @param {MmlNode} prev  The previous node to this one\n   */\n  protected getPrevClass(prev: MmlNode) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel') as number;\n    }\n  }\n\n  /**\n   * @return {string}  returns the spacing to use before this node\n   */\n  public texSpacing(): string {\n    let prevClass = (this.prevClass != null ? this.prevClass : TEXCLASS.NONE);\n    let texClass = this.texClass || TEXCLASS.ORD;\n    if (prevClass === TEXCLASS.NONE || texClass === TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === TEXCLASS.VCENTER) {\n      prevClass = TEXCLASS.ORD;\n    }\n    if (texClass === TEXCLASS.VCENTER) {\n      texClass = TEXCLASS.ORD;\n    }\n    let space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  }\n\n  /**\n   * Sets the inherited propertis for this node, and pushes inherited properties to the children\n   *\n   *   For each inheritable attribute:\n   *     If the node has a default for this attribute, try to inherit it\n   *       but check if the noInherit object prevents that.\n   *   If the node doesn't have an explicit displaystyle, inherit it\n   *   If the node doesn't have an explicit scriptstyle, inherit it\n   *   If the prime style is true, set it as a property (it is not a MathML attribute)\n   *   Check that the number of children is correct\n   *   Finally, push any inherited attributes to teh children.\n   *\n   * @override\n   */\n  public setInheritedAttributes(attributes: AttributeList = {},\n                                display: boolean = false, level: number = 0, prime: boolean = false) {\n    let defaults = this.attributes.getAllDefaults();\n    for (const key of Object.keys(attributes)) {\n      if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n        let [node, value] = attributes[key];\n        let noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n        if (!noinherit[key]) {\n          this.attributes.setInherited(key, value);\n        }\n      }\n    }\n    let displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    let scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    let arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && ((arity === 1 && this.childNodes.length === 0) ||\n                                             (arity !== 1 && this.childNodes.length !== arity))) {\n      //\n      //  Make sure there are the right number of child nodes\n      //  (trim them or add empty mrows)\n      //\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  }\n  /**\n   * Apply inherited attributes to all children\n   * (Some classes override this to handle changes in displaystyle and scriptlevel)\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      child.setInheritedAttributes(attributes, display, level, prime);\n    }\n  }\n  /**\n   * Used by subclasses to add their own attributes to the inherited list\n   * (e.g., mstyle uses this to augment the inherited attibutes)\n   *\n   * @param {AttributeList} current    The current list of inherited attributes\n   * @param {PropertyList} attributes  The new attributes to add into the list\n   */\n  protected addInheritedAttributes(current: AttributeList, attributes: PropertyList) {\n    let updated: AttributeList = {...current};\n    for (const name of Object.keys(attributes)) {\n      if (name !== 'displaystyle' && name !== 'scriptlevel' && name !== 'style') {\n        updated[name] = [this.kind, attributes[name]];\n      }\n    }\n    return updated;\n  }\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  public inheritAttributesFrom(node: MmlNode) {\n    const attributes = node.attributes;\n    const display = attributes.get('displaystyle') as boolean;\n    const scriptlevel = attributes.get('scriptlevel') as number;\n    const defaults: AttributeList = (!attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    });\n    const prime = node.getProperty('texprimestyle') as boolean || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  }\n\n  /**\n   * Verify the attributes, and that there are the right number of children.\n   * Then verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  public verifyTree(options: PropertyList = null) {\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    let arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity &&\n          ((arity === 1 && this.childNodes.length === 0) ||\n           (arity !== 1 && this.childNodes.length !== arity))) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  }\n\n  /**\n   * Verify that all the attributes are valid (i.e., have defaults)\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyAttributes(options: PropertyList) {\n    if (options['checkAttributes']) {\n      const attributes = this.attributes;\n      const bad = [];\n      for (const name of attributes.getExplicitNames()) {\n        if (name.substr(0, 5) !== 'data-' && attributes.getDefault(name) === undefined &&\n            !name.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n          // FIXME: provide a configurable checker for names that are OK\n          bad.push(name);\n        }\n        // FIXME: add ability to check attribute values?\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  }\n\n  /**\n   * Verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyChildren(options: PropertyList) {\n    for (const child of this.childNodes) {\n      child.verifyTree(options);\n    }\n  }\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   * @return {MmlNode}               The constructed merror\n   */\n  public mError(message: string, options: PropertyList, short: boolean = false): MmlNode {\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    let merror = this.factory.create('merror');\n    merror.attributes.set('data-mjx-message', message);\n    if (options['fullErrors'] || short) {\n      let mtext = this.factory.create('mtext');\n      let text = this.factory.create('text') as TextNode;\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Token node class (extends the AbstractMmlNode)\n */\n\nexport abstract class AbstractMmlTokenNode extends AbstractMmlNode {\n\n  /**\n   * Add the attributes common to all token nodes\n   */\n  public static defaults: PropertyList = {\n      ...AbstractMmlNode.defaults,\n    mathvariant: 'normal',\n    mathsize: INHERIT\n  };\n\n  /**\n   * @override\n   */\n  public get isToken() {\n    return true;\n  }\n\n  /**\n   * Get the text of the token node (skipping mglyphs, and combining\n   *   multiple text nodes)\n   */\n  public getText() {\n    let text = '';\n    for (const child of this.childNodes) {\n      if (child instanceof TextNode) {\n        text += child.getText();\n      }\n    }\n    return text;\n  }\n\n  /**\n   * Only inherit to child nodes that are AbstractMmlNodes (not TextNodes)\n   *\n   * @override\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    }\n  }\n\n  /**\n   * Only step into children that are AbstractMmlNodes (not TextNodes)\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Layout class (extends the AbstractMmlNode)\n *\n *  These have inferred mrows (so only one child) and can be\n *  spacelike or embellished based on their contents.\n */\n\nexport abstract class AbstractMmlLayoutNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isSpacelike() {\n    return this.childNodes[0].isSpacelike;\n  }\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public get arity() {\n    return -1;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode-with-base-node Class (extends the AbstractMmlNode)\n *\n *  These have a base element and other elemetns, (e.g., script elements for msubsup).\n *  They can be embellished (if their base is), and get their TeX classes\n *    from their base with their scripts being handled as separate math lists.\n */\n\nexport abstract class AbstractMmlBaseNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    this.getPrevClass(prev);\n    this.texClass = TEXCLASS.ORD;\n    let base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    for (const child of this.childNodes.slice(1)) {\n      if (child) {\n        child.setTeXclass(null);\n      }\n    }\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Empty Class (extends AbstractEmptyNode, implements MmlNode)\n *\n *  These have no children and no attributes (TextNode and XMLNode), so we\n *  override all the methods dealing with them, and with the data that usually\n *  goes with an MmlNode.\n */\n\nexport abstract class AbstractMmlEmptyNode extends AbstractEmptyNode implements MmlNode {\n\n  /**\n   *  Parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * @return {boolean}  Not a token element\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not embellished\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not space-like\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not a container of any kind\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Does not contain new lines\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  No children\n   */\n  public get arity(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  Is not an inferred row\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Is not a container element\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  Parent is the actual parent\n   */\n  public get Parent(): MmlNode {\n    return this.parent;\n  }\n\n  /**\n   * @return {number}  No TeX class\n   */\n  public get texClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevLevel(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return false;\n  }\n\n  /**\n   * return {Attributes}  No attributes, so don't store one\n   */\n  public get attributes(): Attributes {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    return prev;\n  }\n  /**\n   * @override\n   */\n  public texSpacing() {\n    return '';\n  }\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public setInheritedAttributes(_attributes: AttributeList, _display: boolean, _level: number, _prime: boolean) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public inheritAttributesFrom(_node: MmlNode) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @param {PropertyList} options  The options for the check\n   */\n  public verifyTree(_options: PropertyList) {}\n\n  /**\n   *  @override\n   */\n  public mError(_message: string, _options: PropertyList, _short: boolean = false) {\n    return null as MmlNode;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The TextNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class TextNode extends AbstractMmlEmptyNode {\n  /**\n   * The text for this node\n   */\n  protected text: string = '';\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'text';\n  }\n\n  /**\n   * @return {string}  Return the node's text\n   */\n  public getText(): string {\n    return this.text;\n  }\n\n  /**\n   * @param {string} text  The text to use for the node\n   * @return {TextNode}  The text node (for chaining of method calls)\n   */\n  public setText(text: string): TextNode {\n    this.text = text;\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public copy() {\n    return (this.factory.create(this.kind) as TextNode).setText(this.getText());\n  }\n\n  /**\n   * Just use the text\n   */\n  public toString() {\n    return this.text;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The XMLNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class XMLNode extends AbstractMmlEmptyNode {\n  /**\n   * The XML content for this node\n   */\n  protected xml: Object = null;\n\n  /**\n   * DOM adaptor for the content\n   */\n  protected adaptor: DOMAdaptor<any, any, any> = null;\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'XML';\n  }\n\n  /**\n   * @return {Object}  Return the node's XML content\n   */\n  public getXML(): Object {\n    return this.xml;\n  }\n\n  /**\n   * @param {object} xml  The XML content to be saved\n   * @param {DOMAdaptor} adaptor DOM adaptor for the content\n   * @return {XMLNode}  The XML node (for chaining of method calls)\n   */\n  public setXML(xml: Object, adaptor: DOMAdaptor<any, any, any> = null): XMLNode {\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  }\n\n  /**\n   * @return {string}  The serialized XML content\n   */\n  public getSerializedXML(): string {\n    return this.adaptor.serializeXML(this.xml);\n  }\n\n  /**\n   * @override\n   */\n  public copy(): XMLNode {\n    return (this.factory.create(this.kind) as XMLNode).setXML(this.adaptor.clone(this.xml));\n  }\n\n  /**\n   * Just indicate that this is XML data\n   */\n  public toString() {\n    return 'XML data';\n  }\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}