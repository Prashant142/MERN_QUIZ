{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TagsFactory = exports.AllTags = exports.NoTags = exports.AbstractTags = exports.TagInfo = exports.Label = void 0;\nvar TexParser_js_1 = __importDefault(require(\"./TexParser.js\"));\nvar Label = function () {\n  function Label(tag, id) {\n    if (tag === void 0) {\n      tag = '???';\n    }\n    if (id === void 0) {\n      id = '';\n    }\n    this.tag = tag;\n    this.id = id;\n  }\n  return Label;\n}();\nexports.Label = Label;\nvar TagInfo = function () {\n  function TagInfo(env, taggable, defaultTags, tag, tagId, tagFormat, noTag, labelId) {\n    if (env === void 0) {\n      env = '';\n    }\n    if (taggable === void 0) {\n      taggable = false;\n    }\n    if (defaultTags === void 0) {\n      defaultTags = false;\n    }\n    if (tag === void 0) {\n      tag = null;\n    }\n    if (tagId === void 0) {\n      tagId = '';\n    }\n    if (tagFormat === void 0) {\n      tagFormat = '';\n    }\n    if (noTag === void 0) {\n      noTag = false;\n    }\n    if (labelId === void 0) {\n      labelId = '';\n    }\n    this.env = env;\n    this.taggable = taggable;\n    this.defaultTags = defaultTags;\n    this.tag = tag;\n    this.tagId = tagId;\n    this.tagFormat = tagFormat;\n    this.noTag = noTag;\n    this.labelId = labelId;\n  }\n  return TagInfo;\n}();\nexports.TagInfo = TagInfo;\nvar AbstractTags = function () {\n  function AbstractTags() {\n    this.counter = 0;\n    this.allCounter = 0;\n    this.configuration = null;\n    this.ids = {};\n    this.allIds = {};\n    this.labels = {};\n    this.allLabels = {};\n    this.redo = false;\n    this.refUpdate = false;\n    this.currentTag = new TagInfo();\n    this.history = [];\n    this.stack = [];\n    this.enTag = function (node, tag) {\n      var nf = this.configuration.nodeFactory;\n      var cell = nf.create('node', 'mtd', [node]);\n      var row = nf.create('node', 'mlabeledtr', [tag, cell]);\n      var table = nf.create('node', 'mtable', [row], {\n        side: this.configuration.options['tagSide'],\n        minlabelspacing: this.configuration.options['tagIndent'],\n        displaystyle: true\n      });\n      return table;\n    };\n  }\n  AbstractTags.prototype.start = function (env, taggable, defaultTags) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  };\n  Object.defineProperty(AbstractTags.prototype, \"env\", {\n    get: function () {\n      return this.currentTag.env;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractTags.prototype.end = function () {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  };\n  AbstractTags.prototype.tag = function (tag, noFormat) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  };\n  AbstractTags.prototype.notag = function () {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  };\n  Object.defineProperty(AbstractTags.prototype, \"noTag\", {\n    get: function () {\n      return this.currentTag.noTag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTags.prototype, \"label\", {\n    get: function () {\n      return this.currentTag.labelId;\n    },\n    set: function (label) {\n      this.currentTag.labelId = label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractTags.prototype.formatUrl = function (id, base) {\n    return base + '#' + encodeURIComponent(id);\n  };\n  AbstractTags.prototype.formatTag = function (tag) {\n    return '(' + tag + ')';\n  };\n  AbstractTags.prototype.formatId = function (id) {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  };\n  AbstractTags.prototype.formatNumber = function (n) {\n    return n.toString();\n  };\n  AbstractTags.prototype.autoTag = function () {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  };\n  AbstractTags.prototype.clearTag = function () {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  };\n  AbstractTags.prototype.getTag = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    var ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  };\n  AbstractTags.prototype.resetTag = function () {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  };\n  AbstractTags.prototype.reset = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  };\n  AbstractTags.prototype.startEquation = function (math) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    var recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  };\n  AbstractTags.prototype.finishEquation = function (math) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  };\n  AbstractTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.currentTag.env || this.currentTag.tag == null) {\n      return node;\n    }\n    var tag = this.makeTag();\n    var table = this.enTag(node, tag);\n    return table;\n  };\n  AbstractTags.prototype.makeId = function () {\n    this.currentTag.tagId = this.formatId(this.configuration.options['useLabelIds'] ? this.label || this.currentTag.tag : this.currentTag.tag);\n  };\n  AbstractTags.prototype.makeTag = function () {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    var mml = new TexParser_js_1.default('\\\\text{' + this.currentTag.tagFormat + '}', {}, this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml], {\n      id: this.currentTag.tagId\n    });\n  };\n  return AbstractTags;\n}();\nexports.AbstractTags = AbstractTags;\nvar NoTags = function (_super) {\n  __extends(NoTags, _super);\n  function NoTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NoTags.prototype.autoTag = function () {};\n  NoTags.prototype.getTag = function () {\n    return !this.currentTag.tag ? null : _super.prototype.getTag.call(this);\n  };\n  return NoTags;\n}(AbstractTags);\nexports.NoTags = NoTags;\nvar AllTags = function (_super) {\n  __extends(AllTags, _super);\n  function AllTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  AllTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.history.find(function (x) {\n      return x.taggable;\n    })) {\n      return node;\n    }\n    var tag = this.getTag(true);\n    return this.enTag(node, tag);\n  };\n  return AllTags;\n}(AbstractTags);\nexports.AllTags = AllTags;\nvar TagsFactory;\n(function (TagsFactory) {\n  var tagsMapping = new Map([['none', NoTags], ['all', AllTags]]);\n  var defaultTags = 'none';\n  TagsFactory.OPTIONS = {\n    tags: defaultTags,\n    tagSide: 'right',\n    tagIndent: '0.8em',\n    useLabelIds: true,\n    ignoreDuplicateLabels: false\n  };\n  TagsFactory.add = function (name, constr) {\n    tagsMapping.set(name, constr);\n  };\n  TagsFactory.addTags = function (tags) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.keys(tags)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        TagsFactory.add(key, tags[key]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  TagsFactory.create = function (name) {\n    var constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n      throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n  TagsFactory.setDefault = function (name) {\n    defaultTags = name;\n  };\n  TagsFactory.getDefault = function () {\n    return TagsFactory.create(defaultTags);\n  };\n})(TagsFactory = exports.TagsFactory || (exports.TagsFactory = {}));","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAWA;EAOE,eAAmBA,GAAmB,EAASC,EAAe;IAA3C;MAAAD,WAAmB;IAAA;IAAS;MAAAC,OAAe;IAAA;IAA3C,QAAG,GAAHD,GAAG;IAAyB,OAAE,GAAFC,EAAE;EAAgB;EACnE,YAAC;AAAD,CAAC,EARD;AAAaC;AAcb;EAgBE,iBAAqBC,GAAgB,EAChBC,QAAyB,EACzBC,WAA4B,EAC9BL,GAAkB,EAClBM,KAAkB,EAClBC,SAAsB,EACtBC,KAAsB,EACtBC,OAAoB;IAPlB;MAAAN,QAAgB;IAAA;IAChB;MAAAC,gBAAyB;IAAA;IACzB;MAAAC,mBAA4B;IAAA;IAC9B;MAAAL,UAAkB;IAAA;IAClB;MAAAM,UAAkB;IAAA;IAClB;MAAAC,cAAsB;IAAA;IACtB;MAAAC,aAAsB;IAAA;IACtB;MAAAC,YAAoB;IAAA;IAPlB,QAAG,GAAHN,GAAG;IACH,aAAQ,GAARC,QAAQ;IACR,gBAAW,GAAXC,WAAW;IACb,QAAG,GAAHL,GAAG;IACH,UAAK,GAALM,KAAK;IACL,cAAS,GAATC,SAAS;IACT,UAAK,GAALC,KAAK;IACL,YAAO,GAAPC,OAAO;EAAgB;EAE5C,cAAC;AAAD,CAAC,EAzBD;AAAaP;AA6Lb;EAAA;IAMY,YAAO,GAAW,CAAC;IAMnB,eAAU,GAAW,CAAC;IAKzB,kBAAa,GAAiB,IAAI;IAKlC,QAAG,GAA6B,EAAE;IAKlC,WAAM,GAA6B,EAAE;IAKrC,WAAM,GAA2B,EAAE;IAKnC,cAAS,GAA2B,EAAE;IAKtC,SAAI,GAAY,KAAK;IAKrB,cAAS,GAAY,KAAK;IAK1B,eAAU,GAAY,IAAIQ,OAAO,EAAE;IAQhC,YAAO,GAAc,EAAE;IAEzB,UAAK,GAAc,EAAE;IA2MtB,UAAK,GAAG,UAASC,IAAa,EAAEX,GAAY;MACjD,IAAIY,EAAE,GAAG,IAAI,CAACC,aAAa,CAACC,WAAW;MACvC,IAAIC,IAAI,GAAGH,EAAE,CAACI,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,CAACL,IAAI,CAAC,CAAC;MAC3C,IAAIM,GAAG,GAAGL,EAAE,CAACI,MAAM,CAAC,MAAM,EAAE,YAAY,EAAE,CAAChB,GAAG,EAAEe,IAAI,CAAC,CAAC;MACtD,IAAIG,KAAK,GAAGN,EAAE,CAACI,MAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,CAACC,GAAG,CAAC,EAAE;QAC7CE,IAAI,EAAE,IAAI,CAACN,aAAa,CAACO,OAAO,CAAC,SAAS,CAAC;QAC3CC,eAAe,EAAE,IAAI,CAACR,aAAa,CAACO,OAAO,CAAC,WAAW,CAAC;QACxDE,YAAY,EAAE;OACf,CAAC;MACF,OAAOJ,KAAK;IACd,CAAC;EA2BH;EA3OSK,4BAAK,GAAZ,UAAapB,GAAW,EAAEC,QAAiB,EAAEC,WAAoB;IAC/D,IAAI,IAAI,CAACmB,UAAU,EAAE;MACnB,IAAI,CAACC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACF,UAAU,CAAC;;IAElC,IAAI,CAACA,UAAU,GAAG,IAAId,OAAO,CAACP,GAAG,EAAEC,QAAQ,EAAEC,WAAW,CAAC;EAC3D,CAAC;EAEDsB,sBAAWJ,6BAAG;SAAd;MACE,OAAO,IAAI,CAACC,UAAU,CAACrB,GAAG;IAC5B,CAAC;;;;EAMMoB,0BAAG,GAAV;IACE,IAAI,CAACK,OAAO,CAACF,IAAI,CAAC,IAAI,CAACF,UAAU,CAAC;IAClC,IAAI,CAACA,UAAU,GAAG,IAAI,CAACC,KAAK,CAACI,GAAG,EAAE;EACpC,CAAC;EAMMN,0BAAG,GAAV,UAAWvB,GAAW,EAAE8B,QAAiB;IACvC,IAAI,CAACN,UAAU,CAACxB,GAAG,GAAGA,GAAG;IACzB,IAAI,CAACwB,UAAU,CAACjB,SAAS,GAAGuB,QAAQ,GAAG9B,GAAG,GAAG,IAAI,CAAC+B,SAAS,CAAC/B,GAAG,CAAC;IAChE,IAAI,CAACwB,UAAU,CAAChB,KAAK,GAAG,KAAK;EAC/B,CAAC;EAMMe,4BAAK,GAAZ;IACE,IAAI,CAACvB,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC;IAClB,IAAI,CAACwB,UAAU,CAAChB,KAAK,GAAG,IAAI;EAC9B,CAAC;EAEDmB,sBAAcJ,+BAAK;SAAnB;MACE,OAAO,IAAI,CAACC,UAAU,CAAChB,KAAK;IAC9B,CAAC;;;;EAEDmB,sBAAWJ,+BAAK;SAIhB;MACE,OAAO,IAAI,CAACC,UAAU,CAACf,OAAO;IAChC,CAAC;SAND,UAAiBuB,KAAa;MAC5B,IAAI,CAACR,UAAU,CAACf,OAAO,GAAGuB,KAAK;IACjC,CAAC;;;;EASMT,gCAAS,GAAhB,UAAiBtB,EAAU,EAAEgC,IAAY;IACvC,OAAOA,IAAI,GAAG,GAAG,GAAGC,kBAAkB,CAACjC,EAAE,CAAC;EAC5C,CAAC;EAKMsB,gCAAS,GAAhB,UAAiBvB,GAAW;IAC1B,OAAO,GAAG,GAAGA,GAAG,GAAG,GAAG;EACxB,CAAC;EAOSuB,+BAAQ,GAAlB,UAAmBtB,EAAU;IAC3B,OAAO,UAAU,GAAGA,EAAE,CAACkC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;EAC5C,CAAC;EAOSZ,mCAAY,GAAtB,UAAuBa,CAAS;IAC9B,OAAOA,CAAC,CAACC,QAAQ,EAAE;EACrB,CAAC;EAMMd,8BAAO,GAAd;IACE,IAAI,IAAI,CAACC,UAAU,CAACxB,GAAG,IAAI,IAAI,EAAE;MAC/B,IAAI,CAACsC,OAAO,EAAE;MACd,IAAI,CAACtC,GAAG,CAAC,IAAI,CAACuC,YAAY,CAAC,IAAI,CAACD,OAAO,CAAC,EAAE,KAAK,CAAC;;EAEpD,CAAC;EAMMf,+BAAQ,GAAf;IACE,IAAI,CAACS,KAAK,GAAG,EAAE;IACf,IAAI,CAAChC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACpB,IAAI,CAACwB,UAAU,CAAClB,KAAK,GAAG,EAAE;EAC5B,CAAC;EAMMiB,6BAAM,GAAb,UAAciB,KAAsB;IAAtB;MAAAA,aAAsB;IAAA;IAClC,IAAIA,KAAK,EAAE;MACT,IAAI,CAACC,OAAO,EAAE;MACd,OAAO,IAAI,CAACC,OAAO,EAAE;;IAEvB,IAAMC,EAAE,GAAG,IAAI,CAACnB,UAAU;IAC1B,IAAImB,EAAE,CAACvC,QAAQ,IAAI,CAACuC,EAAE,CAACnC,KAAK,EAAE;MAC5B,IAAImC,EAAE,CAACtC,WAAW,EAAE;QAClB,IAAI,CAACoC,OAAO,EAAE;;MAEhB,IAAIE,EAAE,CAAC3C,GAAG,EAAE;QACV,OAAO,IAAI,CAAC0C,OAAO,EAAE;;;IAGzB,OAAO,IAAI;EACb,CAAC;EAMMnB,+BAAQ,GAAf;IACE,IAAI,CAACK,OAAO,GAAG,EAAE;IACjB,IAAI,CAACgB,IAAI,GAAG,KAAK;IACjB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,QAAQ,EAAE;EACjB,CAAC;EAKMvB,4BAAK,GAAZ,UAAawB,MAAkB;IAAlB;MAAAA,UAAkB;IAAA;IAC7B,IAAI,CAACC,QAAQ,EAAE;IACf,IAAI,CAACV,OAAO,GAAG,IAAI,CAACW,UAAU,GAAGF,MAAM;IACvC,IAAI,CAACG,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,MAAM,GAAG,EAAE;EAClB,CAAC;EAKM5B,oCAAa,GAApB,UAAqB6B,IAA6B;IAChD,IAAI,CAACxB,OAAO,GAAG,EAAE;IACjB,IAAI,CAACH,KAAK,GAAG,EAAE;IACf,IAAI,CAACqB,QAAQ,EAAE;IACf,IAAI,CAACtB,UAAU,GAAG,IAAId,OAAO,CAAC,EAAE,EAAE2C,SAAS,EAAEA,SAAS,CAAC;IACvD,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,GAAG,GAAG,EAAE;IACb,IAAI,CAACjB,OAAO,GAAG,IAAI,CAACW,UAAU;IAC9B,IAAI,CAACL,IAAI,GAAG,KAAK;IACjB,IAAMY,SAAS,GAAGJ,IAAI,CAACK,SAAS,CAACD,SAAS;IAC1C,IAAIA,SAAS,EAAE;MACb,IAAI,CAACX,SAAS,GAAG,IAAI;MACrB,IAAI,CAACP,OAAO,GAAGkB,SAAS,CAAClB,OAAO;;EAEpC,CAAC;EAKMf,qCAAc,GAArB,UAAsB6B,IAA6B;IACjD,IAAI,IAAI,CAACR,IAAI,EAAE;MACbQ,IAAI,CAACK,SAAS,CAACD,SAAS,GAAG;QACzBE,KAAK,EAAEN,IAAI,CAACM,KAAK,EAAE;QACnBpB,OAAO,EAAE,IAAI,CAACW;OACf;;IAEH,IAAI,CAAC,IAAI,CAACJ,SAAS,EAAE;MACnB,IAAI,CAACI,UAAU,GAAG,IAAI,CAACX,OAAO;;IAEhCX,MAAM,CAACgC,MAAM,CAAC,IAAI,CAACR,MAAM,EAAE,IAAI,CAACI,GAAG,CAAC;IACpC5B,MAAM,CAACgC,MAAM,CAAC,IAAI,CAACT,SAAS,EAAE,IAAI,CAACI,MAAM,CAAC;EAC5C,CAAC;EAKM/B,+BAAQ,GAAf,UAAgBZ,IAAa,EAAER,GAAY;IACzC,IAAI,CAACA,GAAG,CAACyD,OAAO,IAAI,IAAI,CAACpC,UAAU,CAACrB,GAAG,IACnC,IAAI,CAACqB,UAAU,CAACxB,GAAG,IAAI,IAAI,EAAE;MAC/B,OAAOW,IAAI;;IAEb,IAAIX,GAAG,GAAG,IAAI,CAAC0C,OAAO,EAAE;IACxB,IAAIxB,KAAK,GAAG,IAAI,CAAC2C,KAAK,CAAClD,IAAI,EAAEX,GAAG,CAAC;IACjC,OAAOkB,KAAK;EACd,CAAC;EAqBOK,6BAAM,GAAd;IACE,IAAI,CAACC,UAAU,CAAClB,KAAK,GAAG,IAAI,CAACwD,QAAQ,CACnC,IAAI,CAACjD,aAAa,CAACO,OAAO,CAAC,aAAa,CAAC,GACtC,IAAI,CAACY,KAAK,IAAI,IAAI,CAACR,UAAU,CAACxB,GAAG,GAAI,IAAI,CAACwB,UAAU,CAACxB,GAAG,CAAC;EAChE,CAAC;EAMOuB,8BAAO,GAAf;IACE,IAAI,CAACwC,MAAM,EAAE;IACb,IAAI,IAAI,CAAC/B,KAAK,EAAE;MACd,IAAI,CAACsB,MAAM,CAAC,IAAI,CAACtB,KAAK,CAAC,GAAG,IAAIgC,KAAK,CAAC,IAAI,CAACxC,UAAU,CAACxB,GAAG,EAAE,IAAI,CAACwB,UAAU,CAAClB,KAAK,CAAC;;IAEjF,IAAI2D,GAAG,GAAG,IAAIC,sBAAS,CAAC,SAAS,GAAG,IAAI,CAAC1C,UAAU,CAACjB,SAAS,GAAG,GAAG,EAAE,EAAE,EAC/C,IAAI,CAACM,aAAa,CAAC,CAACoD,GAAG,EAAE;IACjD,OAAO,IAAI,CAACpD,aAAa,CAACC,WAAW,CAACE,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,CAACiD,GAAG,CAAC,EACpB;MAAChE,EAAE,EAAE,IAAI,CAACuB,UAAU,CAAClB;IAAK,CAAC,CAAC;EAC3E,CAAC;EAEH,mBAAC;AAAD,CAAC,EA9SD;AAAaJ;AAsTb;EAA4BiE;EAA5B;;EAcA;EATSC,wBAAO,GAAd,aAAkB,CAAC;EAKZA,uBAAM,GAAb;IACE,OAAO,CAAC,IAAI,CAAC5C,UAAU,CAACxB,GAAG,GAAG,IAAI,GAAGqE,iBAAMC,MAAM,WAAE;EACrD,CAAC;EAEH,aAAC;AAAD,CAAC,CAd2B/C,YAAY;AAA3BrB;AAuBb;EAA6BiE;EAA7B;;EAcA;EATSI,0BAAQ,GAAf,UAAgB5D,IAAa,EAAER,GAAY;IACzC,IAAI,CAACA,GAAG,CAACyD,OAAO,IAAI,IAAI,CAAChC,OAAO,CAAC4C,IAAI,CACnC,UAASC,CAAU;MAAI,OAAOA,CAAC,CAACrE,QAAQ;IAAE,CAAC,CAAC,EAAE;MAC9C,OAAOO,IAAI;;IAEb,IAAIX,GAAG,GAAG,IAAI,CAACsE,MAAM,CAAC,IAAI,CAAC;IAC3B,OAAO,IAAI,CAACT,KAAK,CAAClD,IAAI,EAAEX,GAAG,CAAC;EAC9B,CAAC;EAEH,cAAC;AAAD,CAAC,CAd4BuB,YAAY;AAA5BrB;AA0Bb,IAAiBwE,WAAW;AAA5B,WAAiBA,WAAW;EAE1B,IAAIC,WAAW,GAAG,IAAIC,GAAG,CAAoB,CAC3C,CAAC,MAAM,EAAER,MAAM,CAAC,EAChB,CAAC,KAAK,EAAEG,OAAO,CAAC,CACjB,CAAC;EAEF,IAAIlE,WAAW,GAAG,MAAM;EAMbqE,mBAAO,GAAe;IAE/BG,IAAI,EAAExE,WAAW;IAGjByE,OAAO,EAAE,OAAO;IAEhBC,SAAS,EAAE,OAAO;IAKlBC,WAAW,EAAE,IAAI;IAEjBC,qBAAqB,EAAE;GACxB;EAQUP,eAAG,GAAG,UAASQ,IAAY,EAAEC,MAAiB;IACvDR,WAAW,CAACS,GAAG,CAACF,IAAI,EAAEC,MAAM,CAAC;EAC/B,CAAC;EAOUT,mBAAO,GAAG,UAASG,IAAiC;;;MAC7D,KAAkB,wBAAM,CAACQ,IAAI,CAACR,IAAI,CAAC,6CAAE;QAAhC,IAAMS,GAAG;QACZZ,WAAW,CAACa,GAAG,CAACD,GAAG,EAAET,IAAI,CAACS,GAAG,CAAC,CAAC;;;;;;;;;;;;;EAEnC,CAAC;EAQUZ,kBAAM,GAAG,UAASQ,IAAY;IACvC,IAAIC,MAAM,GAAGR,WAAW,CAACa,GAAG,CAACN,IAAI,CAAC,IAAIP,WAAW,CAACa,GAAG,CAACnF,WAAW,CAAC;IAClE,IAAI,CAAC8E,MAAM,EAAE;MACT,MAAMM,KAAK,CAAC,oBAAoB,CAAC;;IAErC,OAAO,IAAIN,MAAM,EAAE;EACrB,CAAC;EAOUT,sBAAU,GAAG,UAASQ,IAAY;IAC3C7E,WAAW,GAAG6E,IAAI;EACpB,CAAC;EAMUR,sBAAU,GAAG;IACtB,OAAOA,WAAW,CAAC1D,MAAM,CAACX,WAAW,CAAC;EACxC,CAAC;AAEH,CAAC,EAlFgBqE,WAAW,GAAXxE,mBAAW,KAAXA,mBAAW","names":["tag","id","exports","env","taggable","defaultTags","tagId","tagFormat","noTag","labelId","TagInfo","node","nf","configuration","nodeFactory","cell","create","row","table","side","options","minlabelspacing","displaystyle","AbstractTags","currentTag","stack","push","Object","history","pop","noFormat","formatTag","label","base","encodeURIComponent","replace","n","toString","counter","formatNumber","force","autoTag","makeTag","ct","redo","refUpdate","clearTag","offset","resetTag","allCounter","allLabels","allIds","math","undefined","labels","ids","recompile","inputData","state","assign","display","enTag","formatId","makeId","Label","mml","TexParser_js_1","__extends","NoTags","_super","getTag","AllTags","find","x","TagsFactory","tagsMapping","Map","tags","tagSide","tagIndent","useLabelIds","ignoreDuplicateLabels","name","constr","set","keys","key","add","get","Error"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/input/tex/Tags.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Class for generating tags, references, etc.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport TexParser from './TexParser.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MathItem} from '../../core/MathItem.js';\nimport {EnvList} from './StackItem.js';\nimport ParseOptions from './ParseOptions.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n *  Simple class for label objects.\n */\nexport class Label {\n\n  /**\n   * @constructor\n   * @param {string=} tag The tag that's displayed.\n   * @param {string=} id The id that serves as reference.\n   */\n  constructor(public tag: string = '???', public id: string = '') {}\n}\n\n\n/**\n * A simple class for keeping track of tag information.\n */\nexport class TagInfo {\n\n  /**\n   * @constructor\n   * @param {string} env The environment name (e.g., align).\n   * @param {boolean} taggable Environment supports tags (e.g., align* does, but\n   *     split does not.)\n   * @param {boolean} defaultTags Environment is tagged by default (e.g., align\n   *     is, but align* is not).\n   * @param {string} tag The tag name (e.g., 1).\n   * @param {string} tagId The unique id for that tag (e.g., mjx-eqn:1).\n   * @param {string} tagFormat The formatted tag (e.g., \"(1)\").\n   * @param {boolean} noTag A no tagging command has been set (e.g., \\notag,\n   *     \\nonumber).\n   * @param {string} labelId The label referring to the tag.\n   */\n  constructor(readonly env: string = '',\n              readonly taggable: boolean = false,\n              readonly defaultTags: boolean = false,\n              public tag: string = null,\n              public tagId: string = '',\n              public tagFormat: string = '',\n              public noTag: boolean = false,\n              public labelId: string = '') {}\n\n}\n\n\nexport interface Tags {\n\n  /**\n   * The global configurations in which the parsing takes place.\n   * @type {ParseOptions}\n   */\n  configuration: ParseOptions;\n\n  /**\n   * IDs used in this equation.\n   * @type {Object.<boolean>}\n   */\n  ids: {[key: string]: boolean};\n\n  /**\n   * IDs used in previous equations.\n   * @type {Object.<boolean>}\n   */\n  allIds: {[key: string]: boolean};\n\n  /**\n   * Labels in the current equation.\n   * @type {Object.<Label>}\n   */\n  labels: {[key: string]: Label};\n\n  /**\n   * Labels in previous equations.\n   * @type {Object.<Label>}\n   */\n  allLabels: {[key: string]: Label};\n\n  /**\n   * The label to use for the next tag.\n   * @type {string}\n   */\n  label: string;\n\n  /**\n   * True if the equation contains an undefined label and must be reprocessed later.\n   * @type {boolean}\n   */\n  redo: boolean;\n\n  /**\n   * True when recompiling to update undefined references\n   * @type {boolean}\n   */\n  refUpdate: boolean;\n\n  /**\n   * The environment that is currently tagged.\n   * @type {string}\n   */\n  env: string;\n\n  /**\n   * The currently active tag.\n   * @type {TagInfo}\n   */\n  currentTag: TagInfo;\n\n  /**\n   * How to format tags.\n   * @param {string} tag The tag string.\n   * @return {string} The formatted numbered tag.\n   */\n  formatTag(tag: string): string;\n\n  /**\n   * How to format URLs for references.\n   * @param {string} id The reference id.\n   * @param {string} base The base URL in the reference.\n   * @return {}\n   */\n  formatUrl(id: string, base: string): string;\n\n  /**\n   * Set the tag automatically, by incrementing equation number.\n   */\n  autoTag(): void;\n\n  /**\n   * @return {MmlNode|void} Generates and returns the tag node.\n   */\n  getTag(): MmlNode | void;\n\n  /**\n   * Clears tagging information.\n   */\n  clearTag(): void;\n\n  /**\n   * Resets the tag structure after an expression has been typeset.\n   */\n  resetTag(): void;\n\n  /**\n   * Fully resets the tag structure, in particular all the tagging and label\n   * history.\n   * @param {number} offset A new offset value to start counting ids from.\n   */\n  reset(offset?: number): void;\n\n  /**\n   * Initialise tagging for a MathItem\n   * (clear equation-specific labels and ids, set counter\n   * and check for recompile)\n   * @param {MathItem} math   The MathItem for the current equation\n   */\n    startEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Move equation-specific labels and ids to global ones,\n   * save the counter, and mark the MathItem for redos\n   */\n    finishEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Finalizes tag creation.\n   * @param {MmlNode} node\n   * @param {EnvList} env List of environment properties.\n   * @return {MmlNode} The newly created tag.\n   */\n  finalize(node: MmlNode, env: EnvList): MmlNode;\n\n  /**\n   * Starts tagging on a given environment.\n   * @param {string} env The name of the environment.\n   * @param {boolean} taggable True if taggable.\n   * @param {boolean} defaultTags True if tagged by default.\n   */\n  start(env: string, taggable: boolean, defaultTags: boolean): void;\n\n  /**\n   * End tagging.\n   */\n  end(): void;\n\n  /**\n   * Computes the next tag.\n   * @param {string} tag The tag content.\n   * @param {boolean} noFormat True if tag should not be formatted.\n   */\n  tag(tag: string, noFormat: boolean): void;\n\n  /**\n   * Call an explicit no tag.\n   */\n  notag(): void;\n\n  /**\n   * Entag an element by creating a table around it.\n   * @param {MmlNode} node The node to be tagged.\n   * @param {MmlNode} tag The tag node.\n   * @return {MmlNode} The table node containing the original node and tag.\n   */\n  enTag(node: MmlNode, tag: MmlNode): MmlNode;\n}\n\n\nexport class AbstractTags implements Tags {\n\n  /**\n   * Current equation number.\n   * @type {number}\n   */\n  protected counter: number = 0;\n\n  /**\n   * Equation number as equation begins.\n   * @type {number}\n   */\n  protected allCounter: number = 0;\n\n  /**\n   * @override\n   */\n  public configuration: ParseOptions = null;\n\n  /**\n   * @override\n   */\n  public ids: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public allIds: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public labels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public allLabels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public redo: boolean = false;\n\n  /**\n   * @override\n   */\n  public refUpdate: boolean = false;\n\n  /**\n   * @override\n   */\n  public currentTag: TagInfo = new TagInfo();\n\n\n  /**\n   * Chronology of all previous tags, in case we need to look something up in\n   * the finalize method.\n   * @type {TagInfo[]}\n   */\n  protected history: TagInfo[] = [];\n\n  private stack: TagInfo[] = [];\n\n  /**\n   * @override\n   */\n  public start(env: string, taggable: boolean, defaultTags: boolean) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  }\n\n  public get env() {\n    return this.currentTag.env;\n  }\n\n\n  /**\n   * @override\n   */\n  public end() {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public tag(tag: string, noFormat: boolean) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  }\n\n\n  /**\n   * @override\n   */\n  public notag() {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  }\n\n  protected get noTag(): boolean {\n    return this.currentTag.noTag;\n  }\n\n  public set label(label: string) {\n    this.currentTag.labelId = label;\n  }\n\n  public get label() {\n    return this.currentTag.labelId;\n  }\n\n  /**\n   * @override\n   */\n  public formatUrl(id: string, base: string) {\n    return base + '#' + encodeURIComponent(id);\n  }\n\n  /**\n   * @override\n   */\n  public formatTag(tag: string) {\n    return '(' + tag + ')';\n  }\n\n  /**\n   * How to format ids for labelling equations.\n   * @param {string} id The unique part of the id (e.g., label or number).\n   * @return {string} The formatted id.\n   */\n  protected formatId(id: string): string {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  }\n\n  /**\n   * How to format numbers in tags.\n   * @param {number} n The tag number.\n   * @return {string} The formatted number.\n   */\n  protected formatNumber(n: number): string {\n    return n.toString();\n  }\n\n  // Tag handling functions.\n  /**\n   * @override\n   */\n  public autoTag() {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public clearTag() {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  }\n\n\n  /**\n   * @override\n   */\n  public getTag(force: boolean = false) {\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    const ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @override\n   */\n  public resetTag() {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  }\n\n  /**\n   * @override\n   */\n  public reset(offset: number = 0) {\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  }\n\n  /**\n   * @override\n   */\n  public startEquation(math: MathItem<any, any, any>) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    const recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  }\n\n  /**\n   * @override\n   */\n  public finishEquation(math: MathItem<any, any, any>) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  }\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList): MmlNode {\n    if (!env.display || this.currentTag.env ||\n        this.currentTag.tag == null) {\n      return node;\n    }\n    let tag = this.makeTag();\n    let table = this.enTag(node, tag);\n    return table;\n  }\n\n  /**\n   * @override\n   */\n  public enTag = function(node: MmlNode, tag: MmlNode): MmlNode {\n    let nf = this.configuration.nodeFactory;\n    let cell = nf.create('node', 'mtd', [node]);\n    let row = nf.create('node', 'mlabeledtr', [tag, cell]);\n    let table = nf.create('node', 'mtable', [row], {\n      side: this.configuration.options['tagSide'],\n      minlabelspacing: this.configuration.options['tagIndent'],\n      displaystyle: true\n    });\n    return table;\n  };\n\n\n  /**\n   * Sets the tag id.\n   */\n  private makeId() {\n    this.currentTag.tagId = this.formatId(\n      this.configuration.options['useLabelIds'] ?\n        (this.label || this.currentTag.tag) : this.currentTag.tag);\n  }\n\n\n  /**\n   * @return {MmlNode} The actual tag node as an mtd.\n   */\n  private makeTag(): MmlNode {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    let mml = new TexParser('\\\\text{' + this.currentTag.tagFormat + '}', {},\n                            this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml],\n                                                 {id: this.currentTag.tagId});\n  }\n\n}\n\n\n/**\n * No tags, except where explicitly set.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class NoTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public autoTag() {}\n\n  /**\n   * @override\n   */\n  public getTag() {\n    return !this.currentTag.tag ? null : super.getTag();\n  }\n\n}\n\n\n/**\n * Tags every display formula. Exceptions are: Environments that explicitly\n * disallow tags, e.g., equation*.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class AllTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList) {\n    if (!env.display || this.history.find(\n      function(x: TagInfo) { return x.taggable; })) {\n      return node;\n    }\n    let tag = this.getTag(true);\n    return this.enTag(node, tag);\n  }\n\n}\n\n\n/**\n * Class interface for factory.\n * @interface\n */\nexport interface TagsClass {\n  new (): Tags;\n}\n\n\nexport namespace TagsFactory {\n\n  let tagsMapping = new Map<string, TagsClass>([\n    ['none', NoTags],\n    ['all', AllTags]\n  ]);\n\n  let defaultTags = 'none';\n\n  /**\n   * The default options for tagging\n   * @type {OptionList}\n   */\n  export let OPTIONS: OptionList = {\n    // Tagging style, used to be autonumber in v2.\n    tags: defaultTags,\n    // This specifies the side on which \\tag{} macros will place the tags.\n    // Set to 'left' to place on the left-hand side.\n    tagSide: 'right',\n    // This is the amount of indentation (from right or left) for the tags.\n    tagIndent: '0.8em',\n    // make element ID's use \\label name rather than equation number\n    // MJ puts in an equation prefix: mjx-eqn\n    // When true it uses the label name XXX as mjx-eqn:XXX\n    // If false it uses the actual number N that is displayed: mjx-eqn:N\n    useLabelIds: true,\n    // Set to true in order to prevent error messages for duplicate label ids\n    ignoreDuplicateLabels: false\n  };\n\n\n  /**\n   * Add a tagging object.\n   * @param {string} name Name of the tagging object.\n   * @param {TagsClass} constr The class of the Tagging object.\n   */\n  export let add = function(name: string, constr: TagsClass) {\n    tagsMapping.set(name, constr);\n  };\n\n\n  /**\n   * Adds a list of tagging objects to the factory.\n   * @param {{[name: string]: TagsClass}} tags The list of tagging objects.\n   */\n  export let addTags = function(tags: {[name: string]: TagsClass}) {\n    for (const key of Object.keys(tags)) {\n      TagsFactory.add(key, tags[key]);\n    }\n  };\n\n\n  /**\n   * Creates a new tagging object.\n   * @param {string} name The name of the tagging object.\n   * @return {Tags} The newly created object.\n   */\n  export let create = function(name: string): Tags {\n    let constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n        throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n\n\n  /**\n   * Set the name of the default tagging object.\n   * @param {string} name The default.\n   */\n  export let setDefault = function(name: string) {\n    defaultTags = name;\n  };\n\n\n  /**\n   * @return {Tags} The default tagging object.\n   */\n  export let getDefault = function(): Tags {\n    return TagsFactory.create(defaultTags);\n  };\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}