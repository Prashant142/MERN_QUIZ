{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonTextNodeMixin = void 0;\nfunction CommonTextNodeMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_1.prototype.computeBBox = function (bbox, _recompute) {\n      var e_1, _a;\n      if (_recompute === void 0) {\n        _recompute = false;\n      }\n      var variant = this.parent.variant;\n      var text = this.node.getText();\n      if (variant === '-explicitFont') {\n        var font = this.jax.getFontData(this.parent.styles);\n        var _b = this.jax.measureText(text, variant, font),\n          w = _b.w,\n          h = _b.h,\n          d = _b.d;\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        var chars = this.remappedText(text, variant);\n        bbox.empty();\n        try {\n          for (var chars_1 = __values(chars), chars_1_1 = chars_1.next(); !chars_1_1.done; chars_1_1 = chars_1.next()) {\n            var char = chars_1_1.value;\n            var _c = __read(this.getVariantChar(variant, char), 4),\n              h = _c[0],\n              d = _c[1],\n              w = _c[2],\n              data = _c[3];\n            if (data.unknown) {\n              var cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n              w = cbox.w;\n              h = cbox.h;\n              d = cbox.d;\n            }\n            bbox.w += w;\n            if (h > bbox.h) bbox.h = h;\n            if (d > bbox.d) bbox.d = d;\n            bbox.ic = data.ic || 0;\n            bbox.sk = data.sk || 0;\n            bbox.dx = data.dx || 0;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return)) _a.call(chars_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n        bbox.clean();\n      }\n    };\n    class_1.prototype.remappedText = function (text, variant) {\n      var c = this.parent.stretch.c;\n      return c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant));\n    };\n    class_1.prototype.getStyles = function () {};\n    class_1.prototype.getVariant = function () {};\n    class_1.prototype.getScale = function () {};\n    class_1.prototype.getSpace = function () {};\n    return class_1;\n  }(Base);\n}\nexports.CommonTextNodeMixin = CommonTextNodeMixin;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA,SAAgBA,mBAAmB,CAA+BC,IAAO;EAEvE;IAAqBC;IAAd;;IAuFP;IAlFSC,6BAAW,GAAlB,UAAmBC,IAAU,EAAEC,UAA2B;;MAA3B;QAAAA,kBAA2B;MAAA;MACxD,IAAMC,OAAO,GAAG,IAAI,CAACC,MAAM,CAACD,OAAO;MACnC,IAAME,IAAI,GAAI,IAAI,CAACC,IAAiB,CAACC,OAAO,EAAE;MAC9C,IAAIJ,OAAO,KAAK,eAAe,EAAE;QAI/B,IAAMK,IAAI,GAAG,IAAI,CAACC,GAAG,CAACC,WAAW,CAAC,IAAI,CAACN,MAAM,CAACO,MAAM,CAAC;QAC/C,SAAY,IAAI,CAACF,GAAG,CAACG,WAAW,CAACP,IAAI,EAAEF,OAAO,EAAEK,IAAI,CAAC;UAApDK,CAAC;UAAEC,CAAC;UAAEC,CAAC,OAA6C;QAC3Dd,IAAI,CAACa,CAAC,GAAGA,CAAC;QACVb,IAAI,CAACc,CAAC,GAAGA,CAAC;QACVd,IAAI,CAACY,CAAC,GAAGA,CAAC;OACX,MAAM;QACL,IAAMG,KAAK,GAAG,IAAI,CAACC,YAAY,CAACZ,IAAI,EAAEF,OAAO,CAAC;QAC9CF,IAAI,CAACiB,KAAK,EAAE;;UAIZ,KAAmB,4BAAK,4EAAE;YAArB,IAAMC,IAAI;YACT,gBAAkB,IAAI,CAACC,cAAc,CAACjB,OAAO,EAAEgB,IAAI,CAAC;cAAnDL,CAAC;cAAEC,CAAC;cAAEF,CAAC;cAAEQ,IAAI,QAAsC;YACxD,IAAIA,IAAI,CAACC,OAAO,EAAE;cAIhB,IAAMC,IAAI,GAAG,IAAI,CAACd,GAAG,CAACG,WAAW,CAACY,MAAM,CAACC,aAAa,CAACN,IAAI,CAAC,EAAEhB,OAAO,CAAC;cACtEU,CAAC,GAAGU,IAAI,CAACV,CAAC;cACVC,CAAC,GAAGS,IAAI,CAACT,CAAC;cACVC,CAAC,GAAGQ,IAAI,CAACR,CAAC;;YAKZd,IAAI,CAACY,CAAC,IAAIA,CAAC;YACX,IAAIC,CAAC,GAAGb,IAAI,CAACa,CAAC,EAAEb,IAAI,CAACa,CAAC,GAAGA,CAAC;YAC1B,IAAIC,CAAC,GAAGd,IAAI,CAACc,CAAC,EAAEd,IAAI,CAACc,CAAC,GAAGA,CAAC;YAC1Bd,IAAI,CAACyB,EAAE,GAAGL,IAAI,CAACK,EAAE,IAAI,CAAC;YACtBzB,IAAI,CAAC0B,EAAE,GAAGN,IAAI,CAACM,EAAE,IAAI,CAAC;YACtB1B,IAAI,CAAC2B,EAAE,GAAGP,IAAI,CAACO,EAAE,IAAI,CAAC;;;;;;;;;;;;;QAExB,IAAIZ,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;UACpB5B,IAAI,CAAC0B,EAAE,GAAG,CAAC;;QAEb1B,IAAI,CAAC6B,KAAK,EAAE;;IAEhB,CAAC;IAOM9B,8BAAY,GAAnB,UAAoBK,IAAY,EAAEF,OAAe;MAC/C,IAAM4B,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAAC4B,OAAO,CAACD,CAAC;MAC/B,OAAQA,CAAC,GAAG,CAACA,CAAC,CAAC,GAAG,IAAI,CAAC3B,MAAM,CAAC6B,UAAU,CAAC,IAAI,CAACC,YAAY,CAAC7B,IAAI,EAAEF,OAAO,CAAC,CAAC;IAC5E,CAAC;IAWMH,2BAAS,GAAhB,aAAoB,CAAC;IAKdA,4BAAU,GAAjB,aAAqB,CAAC;IAKfA,0BAAQ,GAAf,aAAmB,CAAC;IAKbA,0BAAQ,GAAf,aAAmB,CAAC;IAEtB,cAAC;EAAD,CAAC,CAvFoBF,IAAI;AAyF3B;AA3FAqC","names":["CommonTextNodeMixin","Base","__extends","class_1","bbox","_recompute","variant","parent","text","node","getText","font","jax","getFontData","styles","measureText","w","h","d","chars","remappedText","empty","char","getVariantChar","data","unknown","cbox","String","fromCodePoint","ic","sk","dx","length","clean","c","stretch","remapChars","unicodeChars","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/output/common/Wrappers/TextNode.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonTextNode wrapper mixin for the TextNode object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor} from '../Wrapper.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {TextNode} from '../../../core/MmlTree/MmlNode.js';\n\n/*****************************************************************/\n/**\n * The CommonTextNode interface\n */\nexport interface CommonTextNode extends AnyWrapper {\n  /**\n   * @param {string} text     The text to remap\n   * @param {string} variant  The variant for the character\n   * @return {number[]}       The unicode points for the (remapped) text\n   */\n  remappedText(text: string, variant: string): number[];\n}\n\n/**\n * Shorthand for the CommonTextNode constructor\n */\nexport type TextNodeConstructor = Constructor<CommonTextNode>;\n\n/*****************************************************************/\n/**\n *  The CommonTextNode wrapper mixin for the TextNode object\n *\n * @template T  The Wrapper class constructor type\n */\nexport function CommonTextNodeMixin<T extends WrapperConstructor>(Base: T): TextNodeConstructor & T {\n\n  return class extends Base {\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, _recompute: boolean = false) {\n      const variant = this.parent.variant;\n      const text = (this.node as TextNode).getText();\n      if (variant === '-explicitFont') {\n        //\n        // Measure the size of the text (using the DOM if possible)\n        //\n        const font = this.jax.getFontData(this.parent.styles);\n        const {w, h, d} = this.jax.measureText(text, variant, font);\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        const chars = this.remappedText(text, variant);\n        bbox.empty();\n        //\n        // Loop through the characters and add them in one by one\n        //\n        for (const char of chars) {\n          let [h, d, w, data] = this.getVariantChar(variant, char);\n          if (data.unknown) {\n            //\n            // Measure unknown characters using the DOM (if possible)\n            //\n            const cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n            w = cbox.w;\n            h = cbox.h;\n            d = cbox.d;\n          }\n          //\n          // Update the bounding box\n          //\n          bbox.w += w;\n          if (h > bbox.h) bbox.h = h;\n          if (d > bbox.d) bbox.d = d;\n          bbox.ic = data.ic || 0;\n          bbox.sk = data.sk || 0;\n          bbox.dx = data.dx || 0;\n        }\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n        bbox.clean();\n      }\n    }\n\n    /**\n     * @param {string} text     The text to remap\n     * @param {string} variant  The variant for the character\n     * @return {number[]}       The unicode points for the (remapped) text\n     */\n    public remappedText(text: string, variant: string): number[] {\n      const c = this.parent.stretch.c;\n      return (c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant)));\n    }\n\n    /******************************************************/\n    /*\n     * TextNodes don't need these, since these properties\n     *   are inherited from the parent nodes\n     */\n\n    /**\n     * @override\n     */\n    public getStyles() {}\n\n    /**\n     * @override\n     */\n    public getVariant() {}\n\n    /**\n     * @override\n     */\n    public getScale() {}\n\n    /**\n     * @override\n     */\n    public getSpace() {}\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}