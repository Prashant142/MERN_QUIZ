{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeFactory = void 0;\nvar NodeUtil_js_1 = __importDefault(require(\"./NodeUtil.js\"));\nvar NodeFactory = function () {\n  function NodeFactory() {\n    this.mmlFactory = null;\n    this.factory = {\n      'node': NodeFactory.createNode,\n      'token': NodeFactory.createToken,\n      'text': NodeFactory.createText,\n      'error': NodeFactory.createError\n    };\n  }\n  NodeFactory.createNode = function (factory, kind, children, def, text) {\n    if (children === void 0) {\n      children = [];\n    }\n    if (def === void 0) {\n      def = {};\n    }\n    var node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n    if (text) {\n      node.appendChild(text);\n    }\n    NodeUtil_js_1.default.setProperties(node, def);\n    return node;\n  };\n  NodeFactory.createToken = function (factory, kind, def, text) {\n    if (def === void 0) {\n      def = {};\n    }\n    if (text === void 0) {\n      text = '';\n    }\n    var textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  };\n  NodeFactory.createText = function (factory, text) {\n    if (text == null) {\n      return null;\n    }\n    return factory.mmlFactory.create('text').setText(text);\n  };\n  NodeFactory.createError = function (factory, message) {\n    var text = factory.create('text', message);\n    var mtext = factory.create('node', 'mtext', [], {}, text);\n    var error = factory.create('node', 'merror', [mtext], {\n      'data-mjx-error': message\n    });\n    return error;\n  };\n  NodeFactory.prototype.setMmlFactory = function (mmlFactory) {\n    this.mmlFactory = mmlFactory;\n  };\n  NodeFactory.prototype.set = function (kind, func) {\n    this.factory[kind] = func;\n  };\n  NodeFactory.prototype.setCreators = function (maps) {\n    for (var kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  };\n  NodeFactory.prototype.create = function (kind) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    var func = this.factory[kind] || this.factory['node'];\n    var node = func.apply(void 0, __spreadArray([this, rest[0]], __read(rest.slice(1)), false));\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n    return node;\n  };\n  NodeFactory.prototype.get = function (kind) {\n    return this.factory[kind];\n  };\n  return NodeFactory;\n}();\nexports.NodeFactory = NodeFactory;","map":{"version":3,"mappings":"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","names":["NodeFactory","createNode","createToken","createText","createError","factory","kind","children","def","text","node","mmlFactory","create","setChildren","appendChild","NodeUtil_js_1","setProperties","textNode","setText","message","mtext","error","func","maps","set","_i","rest","slice","configuration","addNode","exports"],"sources":["/Users/prashant/Desktop/react-quiz/node_modules/mathjax-full/ts/input/tex/NodeFactory.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Node factory for creating MmlNodes. This allows extension\n *     packages to add node constructors or overwrite existing ones.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TextNode, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MmlFactory} from '../../core/MmlTree/MmlFactory.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\n\n\nexport type NodeFactoryMethod = (factory: NodeFactory, kind: string, ...rest: any[]) => MmlNode;\n\nexport class NodeFactory {\n\n  /**\n   * Parser configuration that can be used to pass information between node methods.\n   * @type {ParseOption}\n   */\n  public configuration: ParseOptions;\n\n\n  /**\n   * The external node factory.\n   * @type {MmlFactory}\n   */\n  protected mmlFactory: MmlFactory = null;\n\n\n  /**\n   * The factory table populated with some default methods.\n   */\n  private factory: {[kind: string]: NodeFactoryMethod} =\n    {'node': NodeFactory.createNode,\n     'token': NodeFactory.createToken,\n     'text': NodeFactory.createText,\n     'error': NodeFactory.createError\n    };\n\n  /**\n   * Default node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {MmlNode[]} children Its children.\n   * @param {any=} def Its properties.\n   * @param {TextNode=} text An optional text node if this is a token.\n   * @return {MmlNode} The newly created Mml node.\n   */\n  public static createNode(factory: NodeFactory, kind: string,\n                           children: MmlNode[] = [], def: any = {},\n                           text?: TextNode): MmlNode {\n    const node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n    if (text) {\n      node.appendChild(text);\n    }\n    NodeUtil.setProperties(node, def);\n    return node;\n  }\n\n\n  /**\n   * Default token generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {any} def Its properties.\n   * @param {string} text Text of the token.\n   * @return {MmlNode} The newly created token node.\n   */\n  public static createToken(factory: NodeFactory, kind: string,\n                            def: any = {}, text: string = ''): MmlNode  {\n    const textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  }\n\n\n  /**\n   * Default text node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} text The text for the new node.\n   * @return {TextNode} The newly created text node.\n   */\n  public static createText(factory: NodeFactory, text: string): TextNode  {\n    if (text == null) {\n      return null;\n    }\n    return (factory.mmlFactory.create('text') as TextNode).setText(text);\n  }\n\n\n  /**\n   * Default error node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} message The error message.\n   * @return {MmlNode} The newly created error node.\n   */\n  public static createError(factory: NodeFactory, message: string): MmlNode  {\n    let text = factory.create('text', message);\n    let mtext = factory.create('node', 'mtext', [], {}, text);\n    let error = factory.create('node', 'merror', [mtext], {'data-mjx-error': message});\n    return error;\n  }\n\n\n  /**\n   * @param {MmlFactory} mmlFactory   The MmlFactory for the TeX jax to use\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    this.mmlFactory = mmlFactory;\n  }\n\n  /**\n   * Adds a method to the factory.\n   * @param {string} kind The type of node the method creates.\n   * @param {NodeFactoryMethod} func The node creator.\n   */\n  public set(kind: string, func: NodeFactoryMethod) {\n    this.factory[kind] = func;\n  }\n\n\n  /**\n   * Adds a set of node creators to the factory.\n   * @param {Object.<NodeFactoryMethod>} maps The set of functions.\n   */\n  public setCreators(maps: {[kind: string]: NodeFactoryMethod}) {\n    for (let kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  }\n\n\n  /**\n   * Creates a node for the internal data structure from the factory.\n   * @param {string} kind The type of node to be created.\n   * @param {any[]} ...rest The arguments for the node.\n   * @return {MmlNode} The created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    const func = this.factory[kind] || this.factory['node'];\n    const node = func(this, rest[0], ...rest.slice(1));\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n    return node;\n  }\n\n\n  /**\n   * @param {string} kind The method for generating a node of given kind.\n   */\n  public get(kind: string) {\n    return this.factory[kind];\n  }\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}